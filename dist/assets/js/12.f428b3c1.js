(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{599:function(t,a,r){t.exports=r.p+"assets/img/IO-操作对象分类.2539ba1f.png"},600:function(t,a,r){t.exports=r.p+"assets/img/IO-操作方式分类.08a43f00.png"},601:function(t,a,r){t.exports=r.p+"assets/img/同步VS异步.a7960829.jpg"},602:function(t,a,r){t.exports=r.p+"assets/img/阻塞VS非阻塞.6e31d1f8.jpg"},689:function(t,a,r){"use strict";r.r(a);var e=r(5),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"io"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#io"}},[t._v("#")]),t._v(" IO")]),t._v(" "),e("p",[e("img",{attrs:{src:r(599),alt:"IO-操作对象分类"}}),t._v(" "),e("img",{attrs:{src:r(600),alt:"IO-操作方法分类"}})]),t._v(" "),e("h3",{attrs:{id:"输入输出流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#输入输出流"}},[t._v("#")]),t._v(" 输入输出流")]),t._v(" "),e("p",[t._v("StringReader extends Reader\nStringWriter extends Writer")]),t._v(" "),e("p",[t._v("操作数据源为字符串的字符流")]),t._v(" "),e("h3",{attrs:{id:"字符流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符流"}},[t._v("#")]),t._v(" 字符流")]),t._v(" "),e("p",[t._v("Reader  InputStreamReader ， BufferedReader\nWriter  OutputStreamWriter ， BuferedWrite")]),t._v(" "),e("h3",{attrs:{id:"字节流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字节流"}},[t._v("#")]),t._v(" 字节流")]),t._v(" "),e("p",[t._v("InputStream OutputStream")]),t._v(" "),e("p",[t._v("区别：字符流单元是两个字节的Unicode字符，字节流单元是一个字节；\n字符流以字符或字符数组的形式读写数据，只能读写二进制文件，字节流能读写各种类型的数据。音频、图片最好用字节流，避免数据丢失，关系到中文最好用字符流。")]),t._v(" "),e("p",[t._v("字节输入流转字符输入流：通过适配器模式，用InputStreamReader实现，该类构造器可以传入InputStream对象，字节输出流转字符输出流，用OutputStreamWriter。")]),t._v(" "),e("h3",{attrs:{id:"mkdirs-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mkdirs-方法"}},[t._v("#")]),t._v(" mkdirs()方法")]),t._v(" "),e("p",[t._v("file.mkdirs() 如果你想根据File里的路径名建立文件夹（当你不知道此文件夹是否存在，也不知道父文件夹存在），就可用此方法，"),e("br"),t._v("\n它建立文件夹的原则是：如果父文件夹不存在并且最后一级子文件夹不存在，它就自动新建所有路经里写的文件夹；"),e("br"),t._v("\n如果父文件夹存在，它就直接在已经存在的父文件夹下新建子文件夹")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\t\tFile file = new File(fullPath);\n\t\tif (!file.exists()) {\n\t\t\tfile.mkdirs();\n\t\t}\n")])])]),e("h3",{attrs:{id:"同步vs异步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步vs异步"}},[t._v("#")]),t._v(" 同步VS异步")]),t._v(" "),e("p",[t._v("同步I/O：每个请求串行执行，会造成阻塞，用户线程发起I/O请求后需要等待或轮询内核I/O操作完成后才能继续执行。 能够保证程序的可靠性"),e("br"),t._v("\n异步I/O：多个请求并发执行，用户线程发起I/O请求后可以继续执行，当内核I/O操作完成后会通知用户线程，或调用用户线程注册的回调函数。  能够提高程序的性能")]),t._v(" "),e("p",[t._v("着重于是否是否等待任务完成后再继续进行\n"),e("img",{attrs:{src:r(601),alt:"同步VS异步"}})]),t._v(" "),e("h3",{attrs:{id:"阻塞vs非阻塞"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#阻塞vs非阻塞"}},[t._v("#")]),t._v(" 阻塞VS非阻塞")]),t._v(" "),e("p",[t._v("阻塞：请求发出后，所需要的操作条件不满足时，请求一直阻塞，不会返回，知道满足为止。"),e("br"),t._v("\n非阻塞：请求发出后，所需要的操作条件不满足时，立即返回一个标识信息告知条件不满足，而不会一直等待，一般需要循环判断请求条件是否满足来获取请求结果")]),t._v(" "),e("p",[t._v("着重于请求的条件不满足时是否等待\n"),e("img",{attrs:{src:r(602),alt:"阻塞VS非阻塞"}})]),t._v(" "),e("h3",{attrs:{id:"unix下五种i-o模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unix下五种i-o模型"}},[t._v("#")]),t._v(" Unix下五种I/O模型")]),t._v(" "),e("ol",[e("li",[t._v("阻塞I/O\n分两个阶段：")])]),t._v(" "),e("ul",[e("li",[t._v("等待数据就绪，网络IO是等待数据陆续到达，磁盘IO是等待磁盘数据从磁盘上读取到内核态内存")]),t._v(" "),e("li",[t._v("数据拷贝，出于安全，用户态程序无权限直接读取内核态内存，需要把内核态内存拷贝一份到用户态内存中")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("非阻塞I/O\n分三个阶段：")])]),t._v(" "),e("ul",[e("li",[t._v("socket设为NONBLOCK(非阻塞)，则请求的I/O无法完成时，返回一个错误码(EWOULDBLOCK)，这样请求就不会阻塞了")]),t._v(" "),e("li",[t._v("I/O操作函数不断地测试操作数据是否已经准备好，知道数据准备好为止，虽然I/O请求后立即返回了，但是仍需要不断的轮询、重复请求，消耗了大量的CPU资源")]),t._v(" "),e("li",[t._v("数据拷贝")])]),t._v(" "),e("p",[t._v("很少直接只用此模式，但给I/O多路复用提供了条件")]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[e("p",[t._v("I/O多路复用\n用到了select或poll函数，这两个函数也会使线程阻塞，但可以同时阻塞多个I/O，实现了可以一个线程同时处理多个Channel的I/O请求")])]),t._v(" "),e("li",[e("p",[t._v("信号驱动I/O (Java不支持)\nsocket允许信号驱动I/O，并安装一个信号处理函数，数据准备好后线程会收到一个SIGIO信号，调用信号处理函数进行数据处理")])]),t._v(" "),e("li",[e("p",[t._v("异步I/O"),e("br"),t._v("\n前四个模型都是同步阻塞的。"),e("br"),t._v("\n用aio_read 函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。"),e("br"),t._v("\n所以异步I/O模式下，阶段1和阶段2(数据拷贝)全部由内核完成，完成不需要用户线程的参与。")])])]),t._v(" "),e("p",[t._v("Java中，NIO是非阻塞I/O，通过NIO实现的reactor模式是I/O多路复用的实现，通过AIO实现的Proactor模式是异步I/O的实现")]),t._v(" "),e("h3",{attrs:{id:"reactor模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reactor模式"}},[t._v("#")]),t._v(" reactor模式")]),t._v(" "),e("p",[t._v("反应器模式（事件驱动模型），主要有两部分组成BOSS和WORK，BOSS就像老板，拉活、谈项目，然后下发到worker去处理。"),e("br"),t._v("\n处理并发请求，如果有内容进来会自动通知我们，不必开启多个线程死等了。")]),t._v(" "),e("h3",{attrs:{id:"io和nio的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#io和nio的区别"}},[t._v("#")]),t._v(" IO和NIO的区别")]),t._v(" "),e("p",[t._v("IO是阻塞的，调用read(),write()方法"),e("br"),t._v("\nNIO是非阻塞，NIO中引入了缓冲区的概念，对数据的操作都是基于将数据移进、移出缓冲区")]),t._v(" "),e("p",[t._v("IO是面向流的，每次从流中(InputStream/OutputStream)读取一个或多个字节，直到取到所有字节\nNIO是面向缓冲的，数据会被读到一个缓冲区，可以在缓冲区前后移动处理，增加了处理过程的灵活性")]),t._v(" "),e("p",[t._v("NIO中有选择器，一个单独的线程监视多个通道，注册多个通道到一个选择器上\nNIO可以零拷贝，FileChannel拥有transferFrom和transferTo两个方法，可以将FileChannel的数据拷贝到另一个Channel，或者直接把另一个Channel数据拷贝到FileChannel，避免了传输数据时将源数据从内核态拷贝到内存态，再从内存态拷贝到目标内核态这两次上下文切换")]),t._v(" "),e("h2",{attrs:{id:"java中的i-o"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java中的i-o"}},[t._v("#")]),t._v(" Java中的I/O")]),t._v(" "),e("ol",[e("li",[t._v("磁盘操作：file")]),t._v(" "),e("li",[t._v("字节操作：InputStream、OutputStream")]),t._v(" "),e("li",[t._v("字符操作：Reader、Writer")]),t._v(" "),e("li",[t._v("对象操作：serializable")]),t._v(" "),e("li",[t._v("网络操作：Socket")]),t._v(" "),e("li",[t._v("新的IO：  NIO")])]),t._v(" "),e("h3",{attrs:{id:"磁盘操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#磁盘操作"}},[t._v("#")]),t._v(" 磁盘操作")]),t._v(" "),e("h3",{attrs:{id:"字节操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字节操作"}},[t._v("#")]),t._v(" 字节操作")]),t._v(" "),e("p",[t._v("使用了装饰者模式，InputStream属于抽象组件，FileInputStream属于具体组件，FilterInputStream属于抽象装饰者，为组件提供额外的功能，如BufferedInputStream为FileInputStream提供缓存的功能")]),t._v(" "),e("h3",{attrs:{id:"字符操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符操作"}},[t._v("#")]),t._v(" 字符操作")]),t._v(" "),e("p",[t._v('编码：字符--\x3e字节，byte bytes = str.getBytes("UTF-8");'),e("br"),t._v('\n解码：字节--\x3e字符，String str = new String(bytes,"UTF-8");')]),t._v(" "),e("p",[t._v("OutputStreamWriter 字符流--\x3e字节流\nInputStreamReader 实现从字节流解码成字符流")]),t._v(" "),e("h3",{attrs:{id:"对象操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象操作"}},[t._v("#")]),t._v(" 对象操作")]),t._v(" "),e("p",[t._v("序列化，即将对象转换成字节序列，方便存储和传输，ObjectOutputStream.writeObject();\n反序列化，ObjectInputStream.readObject();")]),t._v(" "),e("p",[t._v("不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类状态")]),t._v(" "),e("p",[t._v("transient关键字，表示不能被序列化")]),t._v(" "),e("h3",{attrs:{id:"网络操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络操作"}},[t._v("#")]),t._v(" 网络操作")]),t._v(" "),e("p",[t._v("Java中的网络支持："),e("br"),t._v("\nInetAddress：网络地址，即ip"),e("br"),t._v("\nURL：统一资源定位符"),e("br"),t._v("\nSocket：使用TCP协议实现网络通信。 通过InputStream和OutputStream进行输入输出\nDatagram：使用UDP协议实现网络通信。 DatagramSocket通信类，DatagramPacket数据包类")]),t._v(" "),e("h3",{attrs:{id:"通道"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通道"}},[t._v("#")]),t._v(" 通道")]),t._v(" "),e("p",[t._v("public interface Channel extends Closeable\n常用实现类："),e("br"),t._v("\nFileChannel：从文件中读写数据"),e("br"),t._v("\nSocketChannel：通过TCP读写网络中的数据\nServerSocketChannel：监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel\nDatagramChannel：通过UDP读写网络中的数据")]),t._v(" "),e("h3",{attrs:{id:"缓冲区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓冲区"}},[t._v("#")]),t._v(" 缓冲区")]),t._v(" "),e("p",[t._v("不会对通道直接进行读写操作，而是依靠缓冲区"),e("br"),t._v("\npublic abstract class Buffer"),e("br"),t._v("\n状态变量：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\t// mark <= position <= limit <= capacity\n\t\n\tprivate int mark = -1; \n    private int position = 0; //当前已读的字节数\n    private int limit; //还可以读的字节数\n    private int capacity; //最大容量\n\t\n\tpublic final Buffer flip() { //切换读写\n        limit = position;\n        position = 0;\n        mark = -1;\n        return this;\n    }\n\t\n\tpublic final Buffer clear() { //清空缓冲区\n        position = 0;\n        limit = capacity;\n        mark = -1;\n        return this;\n    }\n\t\n")])])]),e("p",[t._v("实现类有：ByteBuffer，CharBuffer，ShortBuffer，IntBuffer，LongBuffer，DoubleBuffer，FloatBuffer")]),t._v(" "),e("h3",{attrs:{id:"选择器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#选择器"}},[t._v("#")]),t._v(" 选择器")]),t._v(" "),e("ol",[e("li",[t._v("创建选择器")]),t._v(" "),e("li",[t._v("将通道注册到选择器上")]),t._v(" "),e("li",[t._v("监听事件")]),t._v(" "),e("li",[t._v("获取到达的事件")]),t._v(" "),e("li",[t._v("事件循环")])]),t._v(" "),e("h2",{attrs:{id:"文件字节大小转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件字节大小转换"}},[t._v("#")]),t._v(" 文件字节大小转换")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('public static String readableFileSize(long size) {\n        if (size <= 0) return "0";\n        final String[] units = new String[]{"B", "KB", "MB", "GB", "TB"};\n        int digitGroups = (int) (Math.log10(size) / Math.log10(1024));\n        return new DecimalFormat("#,##0.#").format(size / Math.pow(1024, digitGroups)) + " " + units[digitGroups];\n    }\n')])])])])}),[],!1,null,null,null);a.default=s.exports}}]);