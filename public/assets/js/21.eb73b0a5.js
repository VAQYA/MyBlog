(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{577:function(t,n,e){t.exports=e.p+"assets/img/密码分组链接模式.573aeeef.png"},635:function(t,n,e){"use strict";e.r(n);var a=e(5),r=Object(a.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"查找算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查找算法"}},[t._v("#")]),t._v(" 查找算法")]),t._v(" "),a("h3",{attrs:{id:"二分查找"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二分查找"}},[t._v("#")]),t._v(" 二分查找")]),t._v(" "),a("p",[t._v("又叫折半查找算法，基于比较目标值和数组中间元素")]),t._v(" "),a("p",[t._v("待查找的数据必须是有序的")]),t._v(" "),a("p",[t._v("空间复杂度：O(1)\n时间复杂度：O(1)~O(logN) 以2为底N的对数")]),t._v(" "),a("p",[t._v("算法规则： 目标值等于中间元素则找到目标值，目标值小于中间元素则向左侧继续搜索，目标值大于中间元素则向右侧搜索")]),t._v(" "),a("ul",[a("li",[t._v("left+(right-left)/2 和 （right+left)/2 结果一样，但有效的避免了相加结果太大导致溢出")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("int binary_search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1; \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1; \n        } else if(nums[mid] == target) {\n            // 直接返回\n            return mid;\n        }\n    }\n    // 直接返回\n    return -1;\n}\n\n")])])]),a("p",[t._v("//寻找左侧边界的二分查找")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("int left_bound(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else if (nums[mid] == target) {\n            // 别返回，锁定左侧边界\n            right = mid - 1;\n        }\n    }\n    // 最后要检查 left 越界的情况\n    if (left >= nums.length || nums[left] != target)\n        return -1;\n    return left;\n}\n")])])]),a("p",[t._v("//寻找右侧边界")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("int right_bound(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else if (nums[mid] == target) {\n            // 别返回，锁定右侧边界\n            left = mid + 1;\n        }\n    }\n    // 最后要检查 right 越界的情况\n    if (right < 0 || nums[right] != target)\n        return -1;\n    return right;\n}\n")])])]),a("p",[t._v("//https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/")]),t._v(" "),a("h3",{attrs:{id:"插值查找"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插值查找"}},[t._v("#")]),t._v(" 插值查找")]),t._v(" "),a("h3",{attrs:{id:"算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[t._v("#")]),t._v(" 算法")]),t._v(" "),a("p",[t._v("加密算法都是可逆的；"),a("br"),t._v("\n摘要算法都是不可逆的，有信息丢失，不可逆")]),t._v(" "),a("h3",{attrs:{id:"原地算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原地算法"}},[t._v("#")]),t._v(" 原地算法")]),t._v(" "),a("p",[t._v("不依赖额外的资源或依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。")]),t._v(" "),a("h3",{attrs:{id:"哈希算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哈希算法"}},[t._v("#")]),t._v(" 哈希算法")]),t._v(" "),a("p",[t._v("可以将任意长度的输入转化为固定长度的输出")]),t._v(" "),a("h3",{attrs:{id:"md5算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#md5算法"}},[t._v("#")]),t._v(" MD5算法")]),t._v(" "),a("p",[t._v("是哈希算法中的一种，可以将任意长度的字节序列转换为一个128位二进制的摘要，即长度为32的十六进制字符串，区分大小写"),a("br"),t._v("\n是不可逆的"),a("br"),t._v("\n对原数据做一丁点的改动，MD5值就会有巨大的改动")]),t._v(" "),a("p",[t._v("用处：")]),t._v(" "),a("ol",[a("li",[t._v("登录、注册、修改密码等简单加密操作  相对较好的方式：将 服务端md5(客户端md5(pwd)+salt) 保存在数据库")]),t._v(" "),a("li",[t._v("生成数字签名")])]),t._v(" "),a("p",[t._v("彩虹表：是一个庞大的数据库，收集了所有人常用的密码，以及密码所对应的MD5值、SHA-X值等哈希值。"),a("br"),t._v("\n所以加密时最好加盐处理，对每个用户来说盐最好具备唯一性，最好由服务器随机产生并将盐存在数据库。")]),t._v(" "),a("h3",{attrs:{id:"sha-1算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sha-1算法"}},[t._v("#")]),t._v(" SHA-1算法")]),t._v(" "),a("p",[t._v("和MD5算法一样，都是由MD4算法导出，SHA-1算法的长度是40位十六进制数，即160位二进制数，更安全些。")]),t._v(" "),a("h3",{attrs:{id:"aes加密算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aes加密算法"}},[t._v("#")]),t._v(" AES加密算法")]),t._v(" "),a("p",[t._v("是"),a("strong",[t._v("对称加密算法")]),t._v("的一种，采用分组密码体制(将明文切成一段一段的来加密，然后再把一段一段的密文拼起来形成最终密文的加密方式)，"),a("br"),t._v("\n要求密钥的长度可以是128位16个字节，或192位或256位，位数越高加密越强但效率越低，"),a("br"),t._v("\nPadding是用来把不满16个字节的分组数据填满16个字节，"),a("br"),t._v("\n使用AES加密时需要主动提供一个密钥，每段数据加密都使用这个密钥，密钥为随机生成的。")]),t._v(" "),a("p",[t._v("AES四种加密模式，通常使用CBC密码分组链接模式"),a("br"),t._v(" "),a("img",{attrs:{src:e(577),alt:"密码分组链接模式"}})]),t._v(" "),a("p",[t._v("实际开发中服务端和客户端必须使用一样的密钥、初始向量IV、加密模式、Padding模式"),a("br"),t._v("\n一般采用RSA+AES相结合的方式，AES加密数据、RSA加密AES的密钥。")]),t._v(" "),a("h3",{attrs:{id:"rsa加密算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rsa加密算法"}},[t._v("#")]),t._v(" RSA加密算法")]),t._v(" "),a("p",[t._v("是"),a("strong",[t._v("非对称加密算法")]),t._v("的一种，为了保证加密的安全性，RSA密钥的长度一般都是1024位或者2048位，这就使得RSA加密的计算量大、加密速度慢。")])])}),[],!1,null,null,null);n.default=r.exports}}]);