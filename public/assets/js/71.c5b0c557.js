(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{679:function(e,t,r){"use strict";r.r(t);var a=r(5),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"httpservletrequest"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#httpservletrequest"}},[e._v("#")]),e._v(" HttpServletRequest")]),e._v(" "),r("p",[e._v("http://host:port/.../testRequest?key1=value1&key2=value3")]),e._v(" "),r("h3",{attrs:{id:"string-getquerystring"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string-getquerystring"}},[e._v("#")]),e._v(" String getQueryString();")]),e._v(" "),r("p",[e._v("返回请求路径中的参数部分key1=value1&key2=value2&key2=value3")]),e._v(" "),r("h3",{attrs:{id:"string-getparameter-string-key"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string-getparameter-string-key"}},[e._v("#")]),e._v(" String getParameter(String key);")]),e._v(" "),r("p",[e._v("返回请求路径中具体某个参数的值 getParameter(key1); 返回为value1")]),e._v(" "),r("h3",{attrs:{id:"map-string-string-getparametermap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#map-string-string-getparametermap"}},[e._v("#")]),e._v(" Map<String, String[]> getParameterMap();")]),e._v(" "),r("p",[e._v('返回请求路径中所有参数，json格式\n{"key1":["value1"],"key2":["value2","value3"]}')]),e._v(" "),r("h3",{attrs:{id:"报错-java-lang-illegalstateexception-ut010004-cannot-call-getreader-getinputstream-already-called"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#报错-java-lang-illegalstateexception-ut010004-cannot-call-getreader-getinputstream-already-called"}},[e._v("#")]),e._v(" 报错 java.lang.IllegalStateException: UT010004: Cannot call getReader(), getInputStream() already called")]),e._v(" "),r("p",[e._v("ServletRequest的getReader()和getInputStream()两个方法只能被调用一次，而且不能两个都调用")]),e._v(" "),r("h3",{attrs:{id:"通过request获取post请求体的参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#通过request获取post请求体的参数"}},[e._v("#")]),e._v(" 通过request获取post请求体的参数")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("    JsonNode jsonNode = null;\n    BufferedReader reader = request.getReader();  // 或者BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n\t\n    StringWriter writer = new StringWriter();\n    try\n    {\n        int read;\n        char[] buf = new char[1024];\n        while( ( read = reader.read(buf) ) != -1 )\n        {\n            writer.write(buf, 0, read);\n        }\n\n        String s =  writer.getBuffer().toString();\n        ObjectMapper objectMapper = new ObjectMapper();\n        jsonNode = objectMapper.readTree(s);\n    }\n    finally{ writer.close(); }\n    return jsonNode;\n")])])]),r("h3",{attrs:{id:"servlet生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#servlet生命周期"}},[e._v("#")]),e._v(" Servlet生命周期")]),e._v(" "),r("ol",[r("li",[e._v("Tomcat创建Servlet实例")]),e._v(" "),r("li",[e._v("Tomcat调用init()方法初始化实例")]),e._v(" "),r("li",[e._v("处理服务，浏览器访问Servlet后，Servlet会调用Service方法处理请求")]),e._v(" "),r("li",[e._v("销毁，Tomcat关闭或长时间不使用Servlet时，调用destroy()方法")]),e._v(" "),r("li",[e._v("卸载，调用destroy()方法后，等待垃圾回收。如果需要再次使用这个Servlet，会重新调用init()方法初始化。")])]),e._v(" "),r("h3",{attrs:{id:"过滤器-filter"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#过滤器-filter"}},[e._v("#")]),e._v(" 过滤器(Filter)")]),e._v(" "),r("p",[e._v("依赖于Servlet容器，用于过滤一些敏感的字符串、避免中文乱码、权限验证等，缺点是过滤器实例只能在容器初始化时调用一次。"),r("br"),e._v("\n实际上就是实现Filter接口，重写doFilter()方法，通过注解/xml方式部署。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public interface Filter {    \n\tvoid doFilter(ServletRequest request, ServletResponse response, FilterChain var3) throws IOException, ServletException;    \n}\n\n通过FilterChain，使用链式结构层层过滤  \npublic interface FilterChain {\n    void doFilter(ServletRequest var1, ServletResponse var2) throws IOException, ServletException;\n}  \n  \n  过滤器其实是责任链模式的一种实现。  \n")])])]),r("h3",{attrs:{id:"拦截器-interceptor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#拦截器-interceptor"}},[e._v("#")]),e._v(" 拦截器(Interceptor)")]),e._v(" "),r("p",[e._v("基于Java的反射机制，属于面向切面编程的一种运用，在Service方法之前后之后调用，可以在一个Controller生命周期调用多次，缺点是只能对Controller请求进行拦截，对其他 ，比如直接访问静态资源的请求无法拦截处理。")]),e._v(" "),r("h3",{attrs:{id:"监听器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#监听器"}},[e._v("#")]),e._v(" 监听器")]),e._v(" "),r("p",[e._v("实现特定接口的普通Java程序，监听Java对象的方法调用和属性改变。比如统计网站在线人数、自动踢人、定时清除Session。")]),e._v(" "),r("h3",{attrs:{id:"为什么说dispatchsevlet是线程安全的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么说dispatchsevlet是线程安全的"}},[e._v("#")]),e._v(" 为什么说dispatchSevlet是线程安全的")]),e._v(" "),r("p",[e._v("SpringMVC只会初始化一次DispatcherServlet，只有一个实例，多线程访问时DispatcherServlet的内部属性也不会影响线程安全")]),e._v(" "),r("h3",{attrs:{id:"response-reset"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#response-reset"}},[e._v("#")]),e._v(" response.reset()")]),e._v(" "),r("p",[e._v("可以清除首部的空白行")])])}),[],!1,null,null,null);t.default=s.exports}}]);