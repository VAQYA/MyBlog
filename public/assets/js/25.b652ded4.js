(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{600:function(t,r,a){t.exports=a.p+"assets/img/SpringBoot架构.c7d783b6.png"},694:function(t,r,a){"use strict";a.r(r);var e=a(5),o=Object(e.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"spring-boot"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot"}},[t._v("#")]),t._v(" Spring Boot")]),t._v(" "),e("p",[t._v("Spring的子项目。"),e("br"),t._v("\n优点：简化了Spring繁琐的配置，快速整合第三方框架，实现了自动配置，提供了各种启动器，内嵌了Tomcat部署简单"),e("br"),t._v("\n缺点：将传统的Spring Framework项目转换为Spring Boot应用程序比较麻烦，它仅适用于全新的Spring项目；集成度较高，使用过程中不太容易理解底层。"),e("br"),t._v(" "),e("img",{attrs:{src:a(600),alt:"SpringBoot架构"}})]),t._v(" "),e("h3",{attrs:{id:"初始化一个spring-boot项目"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初始化一个spring-boot项目"}},[t._v("#")]),t._v(" 初始化一个Spring Boot项目")]),t._v(" "),e("p",[t._v("https://start.spring.io/")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  <parent>\n        <groupId>cn.kinglian.nfys</groupId>\n\t\t<artifactId>nfys-bss</artifactId>\n        <version>2.0</version>\n    </parent>\n\t// groupId 域.公司名称\n\t// artifactId 项目（模块）名称\n")])])]),e("h3",{attrs:{id:"核心注解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心注解"}},[t._v("#")]),t._v(" 核心注解")]),t._v(" "),e("p",[t._v("@SpringBootApplication 是启动类注解，主要包含了以下三种：")]),t._v(" "),e("ol",[e("li",[t._v("@SpringBootConfiguration 组合了@Configuration注解，实现配置文件的功能")]),t._v(" "),e("li",[t._v("@EnableAutoConfiguration 打开或关闭自动配置的功能")]),t._v(" "),e("li",[t._v("@ComponentScan Spring组件扫描")])]),t._v(" "),e("h3",{attrs:{id:"spring-boot-starter的工作原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot-starter的工作原理"}},[t._v("#")]),t._v(" Spring Boot Starter的工作原理")]),t._v(" "),e("p",[t._v("启动时的三步：")]),t._v(" "),e("ol",[e("li",[t._v("依赖Starter包中寻找resource/META-INF/spring.factories配置文件，根据文件中配置的jar包扫描项目所依赖的jar包。")]),t._v(" "),e("li",[t._v("根据spring.factories配置加载AutoConfigure类")]),t._v(" "),e("li",[t._v("根据@Conditional注解的条件，进行自动配置并将Bean注入到Spring Context")])]),t._v(" "),e("h3",{attrs:{id:"spring-boot自动配置如何实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot自动配置如何实现的"}},[t._v("#")]),t._v(" Spring Boot自动配置如何实现的")]),t._v(" "),e("p",[t._v("Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载。"),e("br"),t._v("\n这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，例ServletWebServerFactoryAutoConfiguration类"),e("br"),t._v("\n这些自动配置类能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，例ServerProperties类")]),t._v(" "),e("p",[t._v("（如何取?）\nXxxxProperties类是通过@ConfigurationProperties注解从全局配置文件中绑定属性到对应的bean上(即xxxProperties的bean)，"),e("br"),t._v("\nxxxxAutoConfiguration类再通过@EnableConfigurationProperties注解将这些bean导入到Spring容器中")]),t._v(" "),e("p",[t._v("XxxxProperties类的含义是：封装配置文件中相关属性；"),e("br"),t._v("\nXxxxAutoConfiguration类的含义是：自动配置类，目的是给容器中添加组件。")]),t._v(" "),e("h3",{attrs:{id:"spring-boot配置加载顺序-不确定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot配置加载顺序-不确定"}},[t._v("#")]),t._v(" Spring Boot配置加载顺序(不确定)")]),t._v(" "),e("ol",[e("li",[t._v(".properties文件")]),t._v(" "),e("li",[t._v(".yml")]),t._v(" "),e("li",[t._v("系统环境变量")]),t._v(" "),e("li",[t._v("命令行参数")])]),t._v(" "),e("h3",{attrs:{id:"spring-boot是否可以使用xml文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot是否可以使用xml文件"}},[t._v("#")]),t._v(" Spring Boot是否可以使用xml文件？")]),t._v(" "),e("p",[t._v("可以，但不建议，使用时用@ImportResource注解引入")]),t._v(" "),e("h3",{attrs:{id:"spring-boot的核心配置文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot的核心配置文件"}},[t._v("#")]),t._v(" Spring Boot的核心配置文件")]),t._v(" "),e("p",[t._v("bootstrap.yml 由父ApplicationContext加载，优先于application.yml的加载，且属性配置不能被覆盖\napplication.yml 由ApplicationContext加载，用于项目的自动化配置")]),t._v(" "),e("h3",{attrs:{id:"spring-profiles"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-profiles"}},[t._v("#")]),t._v(" Spring Profiles")]),t._v(" "),e("p",[t._v("主要用来配置开发环境和生产环境\nspring.profiles.default 默认值，优先级低。当active没有配置时，使用此变量。\nspring.profiles.active 优先级高，指定当前容器使用哪个profile")]),t._v(" "),e("p",[t._v("例子\nspring:\nprofiles:\nactive: dev")]),t._v(" "),e("h3",{attrs:{id:"如何实现-spring-boot-应用程序的安全性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何实现-spring-boot-应用程序的安全性"}},[t._v("#")]),t._v(" 如何实现 Spring Boot 应用程序的安全性？")]),t._v(" "),e("p",[t._v("使用 spring-boot-starter-security 依赖项，添加安全配置类，配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法")]),t._v(" "),e("h3",{attrs:{id:"spring-boot中如何解决跨域问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot中如何解决跨域问题"}},[t._v("#")]),t._v(" Spring Boot中如何解决跨域问题")]),t._v(" "),e("p",[t._v("在后端通过CORS(Cross-origin resource sharing)来解决跨域问题"),e("br"),t._v("\n一个Http请求先走filter，到达Servlet后才进行拦截器的处理，把cors放在filter里，就可以优先于权限拦截器执行")]),t._v(" "),e("h3",{attrs:{id:"spring-boot的监视器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot的监视器"}},[t._v("#")]),t._v(" Spring Boot的监视器")]),t._v(" "),e("p",[t._v("Spring boot actuator 是 spring 启动框架中的重要功能之一 ，对项目进行检查和监控")]),t._v(" "),e("h3",{attrs:{id:"swagger"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#swagger"}},[t._v("#")]),t._v(" Swagger")]),t._v(" "),e("p",[t._v("Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，它使文档能够以与服务器相同的速度更新。")]),t._v(" "),e("h3",{attrs:{id:"spring-boot打包成的jar和普通的jar"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot打包成的jar和普通的jar"}},[t._v("#")]),t._v(" Spring Boot打包成的jar和普通的jar")]),t._v(" "),e("p",[t._v("Spring Boot打包成的jar可以直接运行，java -jar xxx.jar，不能作为普通的jar被其他项目依赖"),e("br"),t._v("\n普通jar解压后就是包名，Spring Boot的jar解压后/BOOT-INF/classess目录下才是我们的代码")]),t._v(" "),e("h3",{attrs:{id:"spring-boot如何进行异常处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot如何进行异常处理"}},[t._v("#")]),t._v(" Spring Boot如何进行异常处理")]),t._v(" "),e("p",[t._v("@ControllerAdvice+@ExceptionHandler")]),t._v(" "),e("p",[t._v("例：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@Slf4j\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler({MaxUploadSizeExceededException.class})\n    public ResponseEntity<ApiResult> maxUploadSizeExceededException(MaxUploadSizeExceededException e) {\n        if (null != e.getMessage()) {\n            if (e.getMessage().contains("The field file exceeds its maximum permitted size of 1048576 bytes.")) {\n                return new ResponseEntity<>(new ApiResult(null, -1, "上传的文件大小不能超过1MB!"), HttpStatus.PAYLOAD_TOO_LARGE);\n            }\n        }\n        log.error("发生异常, e={}", e.getMessage(), e);\n        return new ResponseEntity<>(new ApiResult(e), HttpStatus.OK);\n    }\n')])])]),e("h3",{attrs:{id:"spring-boot分页"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot分页"}},[t._v("#")]),t._v(" Spring Boot分页")]),t._v(" "),e("p",[t._v("spring-boot-starter-data-jpa可实现")]),t._v(" "),e("h3",{attrs:{id:"微服务中如何实现session共享"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#微服务中如何实现session共享"}},[t._v("#")]),t._v(" 微服务中如何实现Session共享")]),t._v(" "),e("p",[t._v("将所有微服务的Session统一保存到Redis上，对Session读取操作时都去读取Redis的Session")]),t._v(" "),e("h3",{attrs:{id:"spring-boot如何实现定时任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot如何实现定时任务"}},[t._v("#")]),t._v(" Spring Boot如何实现定时任务")]),t._v(" "),e("p",[t._v('配置类上添加@EnableScheduling，然后在方法上添加@Scheduled(cron = " 0 0 10,16 * * ?")')]),t._v(" "),e("h3",{attrs:{id:"注解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注解"}},[t._v("#")]),t._v(" 注解")]),t._v(" "),e("p",[t._v("@Import：@Import的实现有很多时候需要借助 ImportSelector 接口，判断如果被@import的是 ImportSelector.class 接口的实现，那么初始化这个被Import的类，然后调用它的selectImports方法去获得所需要的引入的configuration，然后递归处理")]),t._v(" "),e("h1",{attrs:{id:"github上的springboot-learning-example"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#github上的springboot-learning-example"}},[t._v("#")]),t._v(" github上的springboot-learning-example")]),t._v(" "),e("h2",{attrs:{id:"springbootapplication"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#springbootapplication"}},[t._v("#")]),t._v(" @SpringbootApplication")]),t._v(" "),e("p",[t._v("Springboot应用的启动类")]),t._v(" "),e("h2",{attrs:{id:"配置文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置文件"}},[t._v("#")]),t._v(" 配置文件")]),t._v(" "),e("h3",{attrs:{id:"application-properties"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#application-properties"}},[t._v("#")]),t._v(" application.properties")]),t._v(" "),e("p",[t._v("demo.book.name=springboot\ndemo.book.writer=VAQ")]),t._v(" "),e("h3",{attrs:{id:"也可以引用其他的属性值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#也可以引用其他的属性值"}},[t._v("#")]),t._v(" 也可以引用其他的属性值")]),t._v(" "),e("p",[t._v("demo.book.description=${demo.book.writer}${demo.book.writer}")]),t._v(" "),e("h2",{attrs:{id:"application-yml"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#application-yml"}},[t._v("#")]),t._v(" application.yml")]),t._v(" "),e("p",[t._v("demo:\nbook:\nname: springboot\ndemo:\nbook:\nwriter: VAQ")]),t._v(" "),e("p",[t._v("两个同时存在时默认优先application.properties")]),t._v(" "),e("h2",{attrs:{id:"component"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#component"}},[t._v("#")]),t._v(" @Component")]),t._v(" "),e("p",[t._v("泛指组件bean，应用启动时被加载进容器，可细分为@Controller、@Service、@Repository，指控制层、服务层、持久层")]),t._v(" "),e("h3",{attrs:{id:"mapper和-repository"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mapper和-repository"}},[t._v("#")]),t._v(" @Mapper和@Repository")]),t._v(" "),e("p",[t._v("使用@mapper后，不需要在spring配置中设置扫描地址，通过mapper.xml里面的namespace属性对应相关的mapper类，spring将动态的生成Bean后注入到ServiceImpl中。\n@repository则需要在Spring中配置扫描包地址，然后生成dao层的bean，之后被注入到ServiceImpl中")]),t._v(" "),e("h2",{attrs:{id:"propertysource-classpath-book-properties"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#propertysource-classpath-book-properties"}},[t._v("#")]),t._v(' PropertySource("classpath:book.properties")')]),t._v(" "),e("p",[t._v("通过注解引入其他注解文件")]),t._v(" "),e("h2",{attrs:{id:"autowired-required-false"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#autowired-required-false"}},[t._v("#")]),t._v(" @Autowired(required=false)")]),t._v(" "),e("p",[t._v("控制层自动装配属性Bean，默认=false，则允许为null")]),t._v(" "),e("h2",{attrs:{id:"value"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#value"}},[t._v("#")]),t._v(" @Value")]),t._v(" "),e("p",[t._v('@Value("${demo.book.name}")\nprivate String name;')]),t._v(" "),e("p",[t._v("配置文件中必须有demo.book.name 否则会java.lang.IllegalArgumentException 非法参数异常")]),t._v(" "),e("h2",{attrs:{id:"configurationproperties-prefix-demo-book"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#configurationproperties-prefix-demo-book"}},[t._v("#")]),t._v(' @ConfigurationProperties(prefix="demo.book")')]),t._v(" "),e("p",[t._v("指定以demo.book为前缀的对象;\n还可以数据验证，属性类上加@Validated，类属性上加@NotEmpty、@NotNull等，此时属性为空的话会报编译异常：org.springframework.boot.context.properties.bind.BindException")]),t._v(" "),e("h2",{attrs:{id:"restcontroller"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#restcontroller"}},[t._v("#")]),t._v(" @RestController")]),t._v(" "),e("p",[t._v("SpringMVC的注解，实现了REST API")]),t._v(" "),e("h2",{attrs:{id:"requestmapping-book"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#requestmapping-book"}},[t._v("#")]),t._v(' @RequestMapping("/book")')]),t._v(" "),e("p",[t._v("接口路径")]),t._v(" "),e("h2",{attrs:{id:"编码方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编码方式"}},[t._v("#")]),t._v(" 编码方式")]),t._v(" "),e("p",[t._v("Spring Boot 是以 iso-8859 的编码方式读取 application.properties 配置文件。")]),t._v(" "),e("h3",{attrs:{id:"restcontroller-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#restcontroller-2"}},[t._v("#")]),t._v(" @RestController")]),t._v(" "),e("p",[t._v("等于 @ResponseBody + @Controller")]),t._v(" "),e("h3",{attrs:{id:"responsebody"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#responsebody"}},[t._v("#")]),t._v(" @ResponseBody")]),t._v(" "),e("p",[t._v("注解表示该方法的返回值，会直接写入http响应体（不会被视图解析器认为是个视图对象）")]),t._v(" "),e("h3",{attrs:{id:"maven插件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#maven插件"}},[t._v("#")]),t._v(" maven插件")]),t._v(" "),e("p",[t._v("Spring Boot包含一个Maven插件，可以将项目打包为可执行jar")]),t._v(" "),e("h2",{attrs:{id:"启动失败相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#启动失败相关"}},[t._v("#")]),t._v(" 启动失败相关")]),t._v(" "),e("h3",{attrs:{id:"端口号被占用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#端口号被占用"}},[t._v("#")]),t._v(" 端口号被占用")]),t._v(" "),e("p",[t._v("Disconnected from the target VM, address: '127.0.0.1:9596', transport: 'socket'")]),t._v(" "),e("p",[t._v("Process finished with exit code 0")]),t._v(" "),e("h3",{attrs:{id:"没有引入bean组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#没有引入bean组件"}},[t._v("#")]),t._v(" 没有引入Bean组件")]),t._v(" "),e("p",[t._v("Consider defining a bean of type 'demo.springboot.dao.UserRepository' in your configuration.")]),t._v(" "),e("h3",{attrs:{id:"configurationproperties"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#configurationproperties"}},[t._v("#")]),t._v(" @ConfigurationProperties")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@Data\n@Configuration\n@ConfigurationProperties(prefix = "upload")\npublic class UploadPropertes {\n\n    private String root;\n\n}\n\nuploadPropertes.getRoot() 相当于获取application.yml文件中的配置数据D:/temp/upload \nupload:\n  root: D:/temp/upload\n  \n  \n')])])])])}),[],!1,null,null,null);r.default=o.exports}}]);