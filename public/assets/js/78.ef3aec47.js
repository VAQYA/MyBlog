(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{695:function(t,e,a){"use strict";a.r(e);var n=a(5),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("a",{attrs:{href:"https://baike.baidu.com/item/shiro/17753571?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[t._v("Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("Shiro的核心部分是SecurityManager，负责安全认证和授权")]),t._v(" "),a("h3",{attrs:{id:"subject-主体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#subject-主体"}},[t._v("#")]),t._v(" Subject 主体")]),t._v(" "),a("blockquote",[a("p",[t._v("代表了当前操作“用户”，是个抽象概念，不一定是指具体的人，与当前应用交互的任何东西都称为Subject，如第三方进程、后台帐户,网路爬虫、机器人。所有的Subject都绑定到SecurityManager，与Subject的所有交互，都委托给SecurityManager，SecurityManager才是实际的执行者。")])]),t._v(" "),a("blockquote",[a("p",[t._v("通过SecurityUtils.getSubject()来获取Subject，Subject再获取Session对象subject.getSession(),这里的Session对象并不是HttpSession，它不需要依赖http服务器，Shiro的Session的默认实现类实现类：org.apache.shiro.mgt.DelegatingSession")])]),t._v(" "),a("h3",{attrs:{id:"securitymanager-安全管理器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#securitymanager-安全管理器"}},[t._v("#")]),t._v(" SecurityManager 安全管理器")]),t._v(" "),a("blockquote",[a("p",[t._v("相当于SpringMVC中的DispatchServlet，是Shiro的核心部分，所有具体的交互都通过它进行控制，SecurityManager管理着所有Subject、且负责进行认证、授权、会话、缓存的管理。")])]),t._v(" "),a("h3",{attrs:{id:"authenticationinfo-角色信息集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#authenticationinfo-角色信息集合"}},[t._v("#")]),t._v(" AuthenticationInfo 角色信息集合")]),t._v(" "),a("blockquote",[a("p",[t._v("负责Subject认证。")])]),t._v(" "),a("h3",{attrs:{id:"authorizationinfo-角色的权限信息集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#authorizationinfo-角色的权限信息集合"}},[t._v("#")]),t._v(" AuthorizationInfo 角色的权限信息集合")]),t._v(" "),a("blockquote",[a("p",[t._v("授权器，用来决定主题是否有权限进行相应的操作")])]),t._v(" "),a("h3",{attrs:{id:"realm-域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#realm-域"}},[t._v("#")]),t._v(" Realm 域")]),t._v(" "),a("blockquote",[a("p",[t._v("充当了Shiro与数据间的连接器，当用户执行角色登陆和权限验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。相当于一个安全相关的DAO，封装了数据源的连接细节，并在需要时将数据提供给Shiro，配置Shiro时，必须至少指定一个Realm。\nRealm提供AuthenticationInfo和AuthorizationInfo两个对象。")])]),t._v(" "),a("h3",{attrs:{id:"sessionmanager-会话管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sessionmanager-会话管理"}},[t._v("#")]),t._v(" SessionManager 会话管理")]),t._v(" "),a("blockquote",[a("p",[t._v("管理会话生命周期的组件")])]),t._v(" "),a("h3",{attrs:{id:"cachemanager-缓存控制器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cachemanager-缓存控制器"}},[t._v("#")]),t._v(" CacheManager 缓存控制器")]),t._v(" "),a("blockquote",[a("p",[t._v("来管理用户、角色、权限等缓存的，因为这些数据基本上很少改变，放入缓存可以提高访问性能。类似于Map<String,Object>对象，通过put保存对象，get取回对象。")])]),t._v(" "),a("h3",{attrs:{id:"cryptgraphy-密码模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cryptgraphy-密码模块"}},[t._v("#")]),t._v(" Cryptgraphy 密码模块")]),t._v(" "),a("blockquote",[a("p",[t._v("Shiro提供的加密组件，用于密码的加密解密。")])]),t._v(" "),a("ol",[a("li",[t._v("获取Subject对象。")]),t._v(" "),a("li",[t._v("测试当前用户是否已经被认证，即是否已经登录，调用Subject的isAuthenticated（）方法。")]),t._v(" "),a("li",[t._v('没有登录的话，把用户名和密码封装为UsernamePasswordToken对象，UsernamePasswordToken token = new UsernamePasswordToken（"username","password"）;')])]),t._v(" "),a("blockquote"),t._v(" "),a("ul",[a("li",[t._v("创建表单页面")]),t._v(" "),a("li",[t._v("把请求提交到SpringMVC和Handler")]),t._v(" "),a("li",[t._v("获取用户名和密码")])]),t._v(" "),a("p",[t._v("token.setRememberMe(true);")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("调用Subject对象的login(token)方法执行登录。")])]),t._v(" "),a("blockquote",[a("p",[t._v("登录时的几种异常")])]),t._v(" "),a("ul",[a("li",[t._v("UnknownAccountException 没有指定用户 。")]),t._v(" "),a("li",[t._v("IncorrectCredentialsException 账户存在，密码不匹配。")]),t._v(" "),a("li",[t._v("LockedAccountException 用户被锁定。")]),t._v(" "),a("li",[t._v("AuthenticationException 前三种异常的父类。")])]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[t._v("自定义Realm方法，从数据库中获取对应的记录，返回给Shiro")])]),t._v(" "),a("blockquote",[a("p",[t._v("实际上需要继承org.apache.shiro.realm.AuthenticatingRealm类\n实现doGetAuthenticationInfo（AuthenticationToken）方法")])]),t._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[t._v("由Shiro完成与密码的比对")])]),t._v(" "),a("p",[t._v('执行登出 Subject对象的logout()方法。\n判断是否有这个角色，Subject对象调用hasRole("username")方法。\n判断用户是否有这种权限，Subject对象调用isPermitted(“)方法。\n.ini配置文件规则：\n用户名=密码，角色1，角色2\n角色=权限1，权限2\n即根据用户名找角色，再根据角色找权限。\n角色= 类型：操作：实例')]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('applicationContext.xml中配置\n<bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">\n\t<propertry name="securityManager" ref="securityManager"/>\n\t<property name="loginUrl" value="/login.jsp"/>\n\t<property name="successUrl" value="/list.jsp"/>\n\t<property name="unauthorizedUrl" value="/unauthorized.jsp"/>\n\t\n\t\x3c!--配置那些页面需要保护，以及访问这些页面需要的权限,首次配置优先\n\tanon 可以被匿名访问\n\tauthc 必须认证（即登陆）后才能访问的页面\n\tlogout 登出\n\t--\x3e\n\t<propertry name="filterChainDefinitions">\n\t    <value>\n\t\t/login.jsp = anon\n\t\t/shiro/login = anon\n\t\t/shiro/logout = logout\n\t\t\n\t\t/** = authc\n\t\t</value>\n\t</propertry>\n</bean>\n\t\n')])])]),a("p",[t._v("ShiroRealm.java继承AuthenticationRealm类，重写方法doGetAuthenticationInfo（AuthenticationToken token），返回AuthenticationInfo对象")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('方法体：\n1.把AuthenticationToken对象转换成UsernamePasswordToken对象\nAuthenticationToken upToken = (UsernamePasswordToken)token;\n2.从UsernamePasswordToken中获取username\nString username = upToken.getUsername();\n3.调用数据库的方法，从数据库中查询username对应的用户记录\n4.判断异常并抛出\n5.根据用户信息的情况，来构建AuthenticationInfo对象并返回，通常使用的实现类是SimpleAuthenticationInfo\nObject principal = username;//认证的实体信息，可以是username，也可以是实体类对象。\nObject credentials = "123456";//密码。\nString realmName = getName();//获取当前realm对应的name\n\nSimpleAuthenticationInfo info = new SimpleAuthenticationInfo(principal,credentials,realmName);\nreturn info;\n')])])]),a("p",[t._v("密码的比对,通过AuthenticatingRealm的credentialsMatcher属性进行密码的比对。")]),t._v(" "),a("p",[t._v("把字符串加密为MD5：替换当前Realm的credentialsMatcher属性，直接使用HashedCredentialsMatcher对象，并设置加密算法。")]),t._v(" "),a("p",[t._v('String hashAlgorithmName = "MD5";//加密方式\nObject credentials = "123456";//初始密码\nObject salt = null;//盐\nint hashIterations = 1024;//加密次数\nObject result = new SimpleHash(hashAlgorithmName,credentials,salt,hashIterations);//加密结果')]),t._v(" "),a("p",[t._v("授权需要继承AuthoriingRealm类，并实现其doGetAuthorizationInfo方法。AuthorIzingRealm类继承自AuthenticatingRealm，但其并没有实现这个方法，所以认证和授权只需要继承AuthorizingRealm即可，同时实现他的两个抽象方法。")])])}),[],!1,null,null,null);e.default=r.exports}}]);