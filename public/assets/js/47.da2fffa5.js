(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{647:function(t,e,n){"use strict";n.r(e);var a=n(5),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"spring3-0后支持的http请求工具-resttemplate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring3-0后支持的http请求工具-resttemplate"}},[t._v("#")]),t._v(" Spring3.0后支持的http请求工具 RestTemplate")]),t._v(" "),n("p",[t._v("webClient：是Spring-webFlux包下的，非阻塞响应，最低java8支持函数式编程，性能好")]),t._v(" "),n("p",[t._v("RestTemplate：是Spring-webmvc包下的，满足RestFul原则，代码简单，默认依赖jdk的HTTP连接工具，对httpclient进行了封装")]),t._v(" "),n("p",[t._v("HttpClient:是apache httpClient包下的，代码复杂，需要资源回收")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("public interface MultiValueMap<K, V> extends Map<K, List<V>>  //一个key可以存多个value\npublic class HttpHeaders implements MultiValueMap<String, String>, Serializable //请求头\npublic class RequestEntity<T> extends HttpEntity<T>  //请求实体\npublic class ResponseEntity<T> extends HttpEntity<T> //返回实体\n\n\n  @Autowired\n   RestTemplate restTemplate;\n\n")])])]),n("h3",{attrs:{id:"get请求"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#get请求"}},[t._v("#")]),t._v(" GET请求")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('1. 参数name、age在urlString路径上，用占位符依次表示{1}、{2}、、、\n\n\tString urlString1 = "https://nfys-test.kinglian.cn/serviceResourc/User/page?name={1}&age={2}";  \n\tname = "vaq", age = "18";\n\tResponseEntity<User> responseEntity = restTemplate.getForEntity(urlString1, User.class, name, age); \n\n2. 参数map的key和占位符的key相对应\n\n    String urlString2 = "https://nfys-test.kinglian.cn/serviceResourc/User/page?name={name}&age={age}";\n\tMap map = new HashMap();\n\tmap.put("name","vaq");\n\tmap.put("age","18");\n\tResponseEntity<User> responseEntity = restTemplate.getForEntity(urlString2, User.class, map); \n\n3. 使用URI对象，参数可直接拼在地址上，但对中文参数要进行编码\n\n\tString name = "vaq", age = "18"; \n    String urlString3 = "https://nfys-test.kinglian.cn/serviceResourc/User/page?name="+URLEncoder.encode(name, "UTF-8")+"&age="+age;\n\tURI uri = URI.create(urlString3);\n\tResponseEntity<User> responseEntity = restTemplate.getForEntity(urlString, User.class); \n\nUser user = responseEntity.getBody();\n\n\n### getForEntity和getForObject\ngetForEntity可以获取响应头、状态码等\ngetForObject只有响应体，相当于getForEntity().getBody();\n')])])]),n("h3",{attrs:{id:"post请求"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#post请求"}},[t._v("#")]),t._v(" POST请求")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('地址URLString或者URI对象都可以\n\n* 不要请求头时\n1. 参数map对象，地址中参数占位符可有可无\n\nMultiValueMap map = new LinkedMultiValueMap();\nmap.add("name","vaq");\nrestTemplate.postForEntity(urlString,map,User.class);\n\n2. 传递JOSN数据或类对象\nUser user = new User();\nuser.setName("age");\nrestTemplate.postForEntity(urlString,user,User.class);\n\n* 需要请求头时\n\n//请求头\nHttpHeaders httpHeaders = new HttpHeaders();\n        MediaType mediaType = MediaType.APPLICATION_JSON_UTF8;\n        httpHeaders.setContentType(mediaType);\n        httpHeaders.add("Accept",MediaType.APPLICATION_JSON_VALUE);\n//请求体\t\t\nMap<String,Object> map = new HashMap<>();\n        Map body = new HashMap();\n        body.put("roleId","1550246");\n        body.put("roleType","1");\n        map.put("body",body);\n//创建请求实体并调用\nHttpEntity<Map> httpEntity = new HttpEntity<>(map,httpHeaders);\nResponseEntity<String> responseEntity = restTemplate.postForEntity(urlString,httpEntity,String.class);\n\n或者\n\nRequestEntity requestEntity = RequestEntity.post(uri).header("Accept",MediaType.APPLICATION_JSON_VALUE).contentType(MediaType.APPLICATION_JSON_UTF8).body(map);\nResponseEntity<String> responseEntity1 = restTemplate.exchange(requestEntity,String.class);\n')])])]),n("ol",{attrs:{start:"3"}},[n("li",[t._v("form-data表单传值")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.MULTIPART_FORM_DATA);\n        MultiValueMap map = new LinkedMultiValueMap();\n        map.add("pollutantCode",pollutantCode);\n        HttpEntity requestBody = new HttpEntity(map, headers);\n\n        ResponseEntity<String> responseEntity = restTemplate.postForEntity(urlString, requestBody, String.class);\n        \n')])])]),n("h3",{attrs:{id:"delete请求"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#delete请求"}},[t._v("#")]),t._v(" DELETE请求")]),t._v(" "),n("h3",{attrs:{id:"put请求"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#put请求"}},[t._v("#")]),t._v(" PUT请求")]),t._v(" "),n("h3",{attrs:{id:"通用方法请求exchange-可用于封装类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#通用方法请求exchange-可用于封装类"}},[t._v("#")]),t._v(" 通用方法请求exchange,可用于封装类")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('//相对于有请求头的Post请求，需指定方法类型\nResponseEntity<User> responseEntity = restTemplate.exchange("url",HttpMethod.GET,httpEntity,User.class);\nUser result = responseEntity.getBody();\n')])])]),n("h3",{attrs:{id:"mediatype"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mediatype"}},[t._v("#")]),t._v(" MediaType")]),t._v(" "),n("p",[t._v("问题背景：微信支付通知响应报文，之前是response.print,后来改为了@ResponseBody String，发现不好使了，即使业务成功，返回success应答，微信仍然一直通知到极限次数。")]),t._v(" "),n("p",[t._v("排查思路：找convertor，json转换器的没问题，但是他只支持application/json，二微信不接受application/json，string转换器没问题，然后看了看控制器代码，resopnseBody默认mediaType是 application/json,找到问题。")]),t._v(" "),n("p",[t._v('解决方案：制器代码 方法的 mapping 注解后面，增加produces = {"text/plain","application/xml"}')]),t._v(" "),n("h3",{attrs:{id:"注意入参中的key有空格-将接收不到url参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注意入参中的key有空格-将接收不到url参数"}},[t._v("#")]),t._v(" 注意入参中的key有空格，将接收不到url参数")]),t._v(" "),n("p",[t._v('map.put("url ","https://www.baidu.com");')]),t._v(" "),n("h3",{attrs:{id:"resttemplatebuilder"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#resttemplatebuilder"}},[t._v("#")]),t._v(" RestTemplateBuilder")]),t._v(" "),n("p",[t._v("当有自定义的序列化和反序列话的类时候要通过RestTemplateBuilder.build()来注册RestTemplate，替代new RestTemplate();")]),t._v(" "),n("h3",{attrs:{id:"resttemplate配置类实例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#resttemplate配置类实例"}},[t._v("#")]),t._v(" RestTemplate配置类实例")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("@Configuration\npublic class RestTemplateConfig {\n    @Autowired\n    private RestTemplateBuilder restTemplateBuilder;\n\n    @Bean\n    public RestTemplate customRestTemplate(){\n        RestTemplate restTemplate = restTemplateBuilder.build();\n\n        // 客户端请求链接策略\n        HttpComponentsClientHttpRequestFactory httpRequestFactory = new HttpComponentsClientHttpRequestFactory();\n        // 请求超时时间（毫秒）\n        httpRequestFactory.setConnectionRequestTimeout(10*1000);\n        // 连接超时时间（毫秒）\n        httpRequestFactory.setConnectTimeout(10*1000);\n        // 读写超时时间(毫秒)\n        httpRequestFactory.setReadTimeout(10*1000);\n        httpRequestFactory.setHttpClient(httpClientBuilder().build());\n        restTemplate.setRequestFactory(httpRequestFactory);\n\n\n        return restTemplate;\n    }\n\n    /**\n     * 设置Http连接管理器，连接池相关配置\n     */\n    private HttpClientBuilder httpClientBuilder(){\n        HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();\n        httpClientBuilder.setConnectionManager(poolingConnectionManager());\n        ConnectionKeepAliveStrategy connectionKeepAliveStrategy = ((httpResponse, httpContext) -> 20*1000);\n        httpClientBuilder.setKeepAliveStrategy(connectionKeepAliveStrategy);\n        httpClientBuilder.setRetryHandler(new DefaultHttpRequestRetryHandler());\n        RequestConfig requestConfig = RequestConfig.custom()\n                .setConnectionRequestTimeout(10*1000)\n                .setConnectTimeout(10*1000)\n                .setSocketTimeout(10*1000)\n                .build();\n        httpClientBuilder.setDefaultRequestConfig(requestConfig);\n        return httpClientBuilder;\n    }\n\n    /**\n     * 链接线程池管理，可以保持连接不断开（keep-alive）,这样速度会更快\n     */\n    private HttpClientConnectionManager poolingConnectionManager(){\n        PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = new PoolingHttpClientConnectionManager();\n        poolingHttpClientConnectionManager.setMaxTotal(100);// 整个连接池的最大连接数\n        poolingHttpClientConnectionManager.setDefaultMaxPerRoute(50);//每个路由的最大连接数\n        poolingHttpClientConnectionManager.setValidateAfterInactivity(300);\n        poolingHttpClientConnectionManager.closeIdleConnections(15, TimeUnit.SECONDS);\n        poolingHttpClientConnectionManager.closeExpiredConnections();\n        return poolingHttpClientConnectionManager;\n    }\n")])])]),n("h2",{attrs:{id:"重试机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#重试机制"}},[t._v("#")]),t._v(" 重试机制")]),t._v(" "),n("p",[t._v("基于spring-retry的注解方式实现"),n("br"),t._v(" "),n("strong",[t._v("被重调的方法不能和当前方法属于同一个类")])]),t._v(" "),n("p",[t._v("@Retryable注解的方法在发生异常时会重试，参数说明：\nvalue：当指定异常发生时会进行重试 ,HttpClientErrorException是RestClientException的子类。\ninclude：和value一样，默认空。如果 exclude也为空时，所有异常都重试\nexclude：指定异常不重试，默认空。如果 include也为空时，所有异常都重试\nmaxAttemps：最大重试次数，默认3\nbackoff：重试等待策略，默认空\n@Backoff注解为重试等待的策略，参数说明：\ndelay：指定重试的延时时间，默认为1000毫秒\nmultiplier：指定延迟的倍数，比如设置delay=5000，multiplier=2时，第一次重试为5秒后，第二次为5x2=10秒，第三次为5x2x2=20秒。")]),t._v(" "),n("ol",[n("li",[t._v("pom引入依赖包")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("        <dependency>\n            <groupId>org.springframework.retry</groupId>\n            <artifactId>spring-retry</artifactId>\n            <version>1.2.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n        </dependency>\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[t._v("配置类添加注解\n在项目启动类或配置类上添加@EnabelRetry")])]),t._v(" "),n("li",[n("p",[t._v("服务类")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("public interface IRetryService {\n    String getPostHttpString(String urlString, HttpEntity<String> httpEntity);\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('@Slf4j\n@Service\npublic class IRetryServiceImpl implements IRetryService {\n\n    @Autowired\n    private RestTemplateConfig restTemplateConfig;\n    \n    /**\n     * 发起请求，返回异常时重试\n     * @param urlString\n     * @param httpEntity\n     * @return\n     */\n    @Override\n    @Retryable(value = RestClientException.class, maxAttempts = 5, backoff = @Backoff(delay = 5000L,multiplier = 2))\n    public String getPostHttpString(String urlString, HttpEntity<String> httpEntity){\n        System.out.println("发起远程API请求:" + DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now()));\n        String responseEntity = restTemplateConfig.customRestTemplate().postForObject(urlString, httpEntity, String.class);\n        return responseEntity;\n    }\n')])])])])}),[],!1,null,null,null);e.default=s.exports}}]);