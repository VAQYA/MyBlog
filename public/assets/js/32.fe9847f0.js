(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{628:function(e,t,a){"use strict";a.r(t);var n=a(5),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[e._v("#")]),e._v(" 定义")]),e._v(" "),a("p",[e._v("通过@interface定义，比接口多个@\n注： 注解并不是代码本身的一部分。")]),e._v(" "),a("h3",{attrs:{id:"元注解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元注解"}},[e._v("#")]),e._v(" 元注解")]),e._v(" "),a("p",[e._v("可以注解到注解上的注解，是一种基本注解，有5种。")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("@Retention 说明注解的存活时间\n取值：\nRetentionPolicy.SOURCE ,只在源码阶段保留，在编译器编译时将被丢弃忽视。\nRetention.CLASS , 注解只被保留在编译进行的时候，不会被加载到JVM\nRetention.RUNTIME , 可以保留在程序运行的时候，会被加载到JVM，所以程序运行时可以获取到它们。")])]),e._v(" "),a("li",[a("p",[e._v("@Documented 将注解中的元素包含到javadoc中")])]),e._v(" "),a("li",[a("p",[e._v("@Target 用于指定注解可以运用的地方\n取值：\nElementType.TYPE , 可以给类型注解，如类、接口、枚举\nElementType.FIELD , 给属性注解\nElementType.METHOD , 方法\nElementType.PARAMETER , 形参\nElementType.CONSTRUCTOR , 构造器\nElementType.LOCAL_VARIABLE , 局部变量\nElementType.ANNOTATION_TYPE , 表示可以给注解进行注解\nElementType.PAKAGE, 包\nElementType.TYPE_PARAMETER , 指定参数类型（1.8之后）\nElementType.TYPE_USE , (1.8之后）")])]),e._v(" "),a("li",[a("p",[e._v("@Inherited 继承\n注解Test被@Inherited注解，类A被Test所注解，类B继承A，则也拥有Test这个注解")])]),e._v(" "),a("li",[a("p",[e._v("@Repeatable 可重复（1.8之后）\n被它注解的注解可以同时取多个")])])]),e._v(" "),a("h3",{attrs:{id:"注解的属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注解的属性"}},[e._v("#")]),e._v(" 注解的属性")]),e._v(" "),a("p",[e._v("即成员变量，注解没有方法")]),e._v(" "),a("h3",{attrs:{id:"常用注解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用注解"}},[e._v("#")]),e._v(" 常用注解")]),e._v(" "),a("p",[e._v("@Deprecated 标志已过时的元素\n@Override 提醒子类要重写父类的此方法\n@SuppressWarnings 忽略编译警告 ，应在尽可能小的范围内使用它\n@SafeVarargs 提醒开发者不要用参数做不安全的操作，它会阻止编译器产生unchecked 警告\n@FunctionalInterface 函数式接口注解，表示一个仅有一个方法的接口 （1.8加入）\n@JsonFormat主要是后台到前台的时间格式的转换\n@DateTimeFormat主要是前端到后台的时间格式的转换")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('\t//入参\n    @DateTimeFormat(pattern="yyyy-MM-dd HH:mm:ss")\n    private LocalDateTime startTime;\n\t\n\t// xml中是SQL语句，只判null不能判\'\'，否则会报错\n\t<if test="startTime !=null ">\n        AND create_time <![CDATA[>=]]> #{startTime}\n    </if>\n\t\n\t\n')])])]),a("h3",{attrs:{id:"作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[e._v("#")]),e._v(" 作用")]),e._v(" "),a("ol",[a("li",[e._v("提供信息给编译器")]),e._v(" "),a("li",[e._v("编译阶段时的处理，软件工具可以根据注解生成代码、HTML文档，或做其他处理")]),e._v(" "),a("li",[e._v("可以在程序运行时接受代码的处理。如用反射")])]),e._v(" "),a("h3",{attrs:{id:"service和-bean"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service和-bean"}},[e._v("#")]),e._v(" @Service和@Bean")]),e._v(" "),a("h3",{attrs:{id:"qualifier-name1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#qualifier-name1"}},[e._v("#")]),e._v(' @Qualifier("name1")')]),e._v(" "),a("p",[e._v('一个接口可能有多个实现类，多个实现类上都有@Service, @Qualifier("name1")表示指明调用@Service("name1")的这个，name1必须是已经定义过@Service("name1")注解的名称，或@Bean("name1")过的')]),e._v(" "),a("h2",{attrs:{id:"lombok"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lombok"}},[e._v("#")]),e._v(" Lombok")]),e._v(" "),a("p",[e._v("@Accessors(chain=true)，链式访问，该注解设置chain=true，生成setter方法返回this（也就是返回的是对象），代替了默认的返回void。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('\t//开起chain=true后可以使用链式的set\n\tUser user=new User().setAge(31).setName("pollyduan");//返回对象\n')])])]),a("p",[e._v("@Accessors(fluent = true)，与chain=true类似，区别在于getter和setter不带set和get前缀。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('\t//fluent=true开启后默认chain=true，故这里也可以使用链式set\n\tUser user=new User().age(31).name("pollyduan");//不需要写set\n')])])]),a("h2",{attrs:{id:"实体类字段上的-tablefield"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实体类字段上的-tablefield"}},[e._v("#")]),e._v(" 实体类字段上的@TableField")]),e._v(" "),a("p",[e._v('value = "station_code" ，表示对应的数据库字段，相当于在xml中开启驼峰映射'),a("br"),e._v("\ncondition = SqlCondition.LIKE ，where条件自定义规则\nexist = false ，表示该属性不是数据库表存在的字段\nfill = FieldFill.INSERT ，插入\nfill = FieldFill.INSERT_UPDATE 插入或更新")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('使用fill自动填充时配置填充数据\n@Component\npublic class MybatisPlusAutoFillConfig implements MetaObjectHandler {\n\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        setFieldValByName("createTime", LocalDateTime.now(), metaObject);\n        setFieldValByName("updateTime", LocalDateTime.now(), metaObject);\n    }\n\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        setFieldValByName("updateTime", LocalDateTime.now(), metaObject);\n    }\n\n}\n')])])]),a("h2",{attrs:{id:"springframework"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#springframework"}},[e._v("#")]),e._v(" Springframework")]),e._v(" "),a("p",[e._v("@Cacheable")])])}),[],!1,null,null,null);t.default=s.exports}}]);