<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2Funcategorized%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[查找算法二分查找又叫折半查找算法，基于比较目标值和数组中间元素 待查找的数据必须是有序的 空间复杂度：O(1)时间复杂度：O(1)~O(logN) 以2为底N的对数 算法规则： 目标值等于中间元素则找到目标值，目标值小于中间元素则向左侧继续搜索，目标值大于中间元素则向右侧搜索 left+(right-left)/2 和 （right+left)/2 结果一样，但有效的避免了相加结果太大导致溢出 12345678910111213141516int binary_search(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if(nums[mid] == target) &#123; // 直接返回 return mid; &#125; &#125; // 直接返回 return -1;&#125; //寻找左侧边界的二分查找123456789101112131415161718int left_bound(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if (nums[mid] == target) &#123; // 别返回，锁定左侧边界 right = mid - 1; &#125; &#125; // 最后要检查 left 越界的情况 if (left &gt;= nums.length || nums[left] != target) return -1; return left;&#125; //寻找右侧边界123456789101112131415161718int right_bound(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if (nums[mid] == target) &#123; // 别返回，锁定右侧边界 left = mid + 1; &#125; &#125; // 最后要检查 right 越界的情况 if (right &lt; 0 || nums[right] != target) return -1; return right;&#125; //https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/ 插值查找]]></content>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2Funcategorized%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型List 读作E的列表 不确定或不关心实际的类型参数，可用？代替 类型擦除泛型是在编译器层次上实现的，编译器会去掉这个类型参数，生成的字节码中不包含泛型中的类型信息，这个过程就是类型擦除eg: List和List编译后都会变成List 常用通配符？ 表示不确定T 表示具体的一个Java类型K,V 表示键值对E 表示 Element]]></content>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2Funcategorized%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[什么是反射？在运行中，对于任何一个类，能够知道它的所有属性和方法；对于任何一个对象，能够调用它的属性和方法。这样能够根据字节码文件获取类信息、字段信息、方法信息等内容，创建实例调用方法的技术。将字节码中的方法、变量、构造函数等映射出相应的Method、Filed、Construct等类，这些类提供了丰富的方法供我们使用JVM在运行时才动态加载类或调用方法、访问属性，不需要在事先(编译期)知道运行的对象是什么类型 提供的功能 判断实例对象所属的类 1类对象.isInstance(实例对象) 判断类所具有的成员变量和方法 构造一个类的对象 1231. 对象的getClass()2. 类名.class3. Class.forName("类的路径"); 调用对象的方法 反射的基石字节码文件对象，即Class类的对象 字节码文件对象的三种获取方式mybatis如何将SQL执行结果封装为目标对象并返回的？ 标签 SQL语句中起别名mybatis通过反射创建对象，通过反射给对象的属性逐一赋值并返回 哪里用到反射？ 框架用的最多的就是反射，如Spring注入属性 加载驱动 （jdbc） Web服务器中利用反射调用了Sevlet的服务方法 获取配置文件 IDEA等开发工具利用反射动态刨析对象的类型与结构，动态提示对象的属性和方法 Spring的IOC实现原理就是工厂模式+反射机制AOP的动态代理 优缺点优点：动态加载类，提高代码灵活度缺点：运行速度比直接操作java代码要慢，能直接操作改变类的属性，有安全隐患 反射中Class.forName()和classLoader的区别Class.forName()除了将.class文件加载到JVM中，还会对文件进行解释，执行类中的static块]]></content>
  </entry>
  <entry>
    <title><![CDATA[Shell]]></title>
    <url>%2Funcategorized%2FShell%2F</url>
    <content type="text"><![CDATA[vaqscentos~centos123456root~centos123456 Shell切换到测试服接口日志目录cd /mnt/logs/nfys-2.0-all-log/logs /开头表示根目录，否则表示当前目录下的子文件夹。 打开某一日志实时显示tail -f nfys-umc.log tail -f nfys-placeMall.log 打开某一日志vim nfys-umc.log 查看/编辑文件vi nfys-umc.log按i进入编辑模式Esc退出编辑模式 搜索:/ 按n向下跳转到搜索的关键字，按N向上跳转:? 按n向上跳转到搜索的关键字，按N向下跳转 保存但不退出:w 强保存但不退出:w! 不保存退出:q 不保存强制退出:q! 保存并退出:wq 强保存并退出:wq! 放弃所有修改:e! 将vi暂停Ctrl+Z 复制Ctrl + Insert 粘贴Shift + Insert 回到上级目录cd .. 回到上两级目录cd ../.. 切换到用户目录cd ~ 创建目录xxmkdir xx 展示当前文件夹下的所有文件及文件夹ls 复制整个文件夹下的所有文件sz dir_name/* 下载某个文件sz nfys-umc.log 补全命令Tab 连按两下列出所有可用命令 本行开头、结尾Home End 上下翻页PgUp PgDn 清屏Ctrl+L 或 clear LinuxLinux 虚拟机节点与节点、节点与宿主机、节点与外网 SSH终端：SecureCRTSFTP文件传输工具：Transmit bootProto=dhcp 自动配置ip地址，ip会变bootProto=static ip地址改为静态的 管理套件rpm yum 基于rpm包管理，能够从指定服务器自动下载RPM包并且安装 根据字符串查找文件grep 判读是否有安装过MySQLrpm -qi | grep -i mysql ###yum -y install]]></content>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2Funcategorized%2FServlet%2F</url>
    <content type="text"><![CDATA[HttpServletRequesthttp://host:port/.../testRequest?key1=value1&amp;key2=value3 String getQueryString();返回请求路径中的参数部分key1=value1&amp;key2=value2&amp;key2=value3 String getParameter(String key);返回请求路径中具体某个参数的值 getParameter(key1); 返回为value1 Map&lt;String, String[]&gt; getParameterMap();返回请求路径中所有参数，json格式{“key1”:[“value1”],”key2”:[“value2”,”value3”]} 报错 java.lang.IllegalStateException: UT010004: Cannot call getReader(), getInputStream() already calledServletRequest的getReader()和getInputStream()两个方法只能被调用一次，而且不能两个都调用 通过request获取post请求体的参数JsonNode jsonNode = null; BufferedReader reader = request.getReader(); // 或者BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream())); StringWriter writer = new StringWriter(); try { int read; char[] buf = new char[1024]; while( ( read = reader.read(buf) ) != -1 ) { writer.write(buf, 0, read); } String s = writer.getBuffer().toString(); ObjectMapper objectMapper = new ObjectMapper(); jsonNode = objectMapper.readTree(s); } finally{ writer.close(); } return jsonNode; ###]]></content>
  </entry>
  <entry>
    <title><![CDATA[RestTemplate]]></title>
    <url>%2Funcategorized%2FRestTemplate%2F</url>
    <content type="text"><![CDATA[Spring3.0后支持的http请求工具 RestTemplatepublic interface MultiValueMap&lt;K, V&gt; extends Map&lt;K, List&gt; //一个key可以存多个valuepublic class HttpHeaders implements MultiValueMap&lt;String, String&gt;, Serializable //请求头public class RequestEntity extends HttpEntity //请求实体public class ResponseEntity extends HttpEntity //返回实体 @Autowired RestTemplate restTemplate; GET请求 参数name、age在urlString路径上，用占位符依次表示{1}、{2}、、、 String urlString1 = “https://nfys-test.kinglian.cn/serviceResourc/User/page?name={1}&amp;age={2}&quot; , name = “vaq”, age = “18”; ResponseEntity responseEntity = restTemplate.getForEntity(urlString1, User.class, name, age); 参数map的key和占位符的key相对应 String urlString2 = “https://nfys-test.kinglian.cn/serviceResourc/User/page?name={name}&amp;age={age}&quot;; Map map = new HashMap(); map.put(“name”,”vaq”); map.put(“age”,”18”); ResponseEntity responseEntity = restTemplate.getForEntity(urlString2, User.class, map); 使用URI对象，参数可直接拼在地址上，但对中文参数要进行编码 String name = “vaq”, age = “18”; String urlString3 = “https://nfys-test.kinglian.cn/serviceResourc/User/page?name=&quot;+URLEncoder.encode(name, “UTF-8”)+”&amp;age=”+age; URI uri = URI.create(urlString3); ResponseEntity responseEntity = restTemplate.getForEntity(urlString, User.class); User user = responseEntity.getBody(); getForEntity和getForObjectgetForEntity可以获取响应头、状态码等getForObject只有响应体，相当于getForEntity().getBody(); POST请求地址URLString或者URI对象都可以 不要请求头时 参数map对象，地址中参数占位符可有可无 MultiValueMap map = new LinkedMultiValueMap&lt;&gt;();map.put(“name”,”vaq”);restTemplate.postForEntity(urlString,map,User.class); 传递JOSN数据或类对象User user = new User();user.setName(“age”);restTemplate.postForEntity(urlString,user,User.class); 需要请求头时 //请求头HttpHeaders httpHeaders = new HttpHeaders(); MediaType mediaType = MediaType.APPLICATION_JSON_UTF8; httpHeaders.setContentType(mediaType); httpHeaders.add(“Accept”,MediaType.APPLICATION_JSON_VALUE);//请求体Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); Map body = new HashMap(); body.put(“roleId”,”1550246”); body.put(“roleType”,”1”); map.put(“body”,body);//创建请求实体并调用HttpEntity httpEntity = new HttpEntity&lt;&gt;(map,httpHeaders);ResponseEntity responseEntity = restTemplate.postForEntity(urlString,httpEntity,String.class); 或者 RequestEntity requestEntity = RequestEntity.post(uri).header(“Accept”,MediaType.APPLICATION_JSON_VALUE).contentType(MediaType.APPLICATION_JSON_UTF8).body(map);ResponseEntity responseEntity1 = restTemplate.exchange(requestEntity,String.class); DELETE请求PUT请求通用方法请求exchange,可用于封装类//相对于有请求头的Post请求，需指定方法类型ResponseEntity responseEntity = restTemplate.exchange(“url”,HttpMethod.GET,httpEntity,User.class);User result = responseEntity.getBody(); MediaType问题背景：微信支付通知响应报文，之前是response.print,后来改为了@ResponseBody String，发现不好使了，即使业务成功，返回success应答，微信仍然一直通知到极限次数。 排查思路：找convertor，json转换器的没问题，但是他只支持application/json，二微信不接受application/json，string转换器没问题，然后看了看控制器代码，resopnseBody默认mediaType是 application/json,找到问题。 解决方案：制器代码 方法的 mapping 注解后面，增加produces = {“text/plain”,”application/xml”} 注意入参中的key有空格，将接收不到url参数map.put(“url “,”https://www.baidu.com&quot;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ]]></title>
    <url>%2Funcategorized%2FRabbitMQ%2F</url>
    <content type="text"><![CDATA[RabbitMQ默认端口号client端通信口5672管理口15672server间内部通信口25672 delivery Mode 发送方式durable 持久的persistent 持久的confirm 确认 优点 系统解耦 异步调用 流量削峰 流程 （动态路由为例）生产者 创建连接工厂 连接工厂对象创建连接 连接对象创建通道 通道对象声明交换器 通道对象发布消息（传入交换器名称、路由key、消息内容）消费者 创建连接工厂 连接工厂对象创建连接 连接对象创建通道 通道对象声明交换器 声明队列（传入队列名称、是否持久化、是否独占模式、消费者断开连接时是否删除、其他参数） 通道对象绑定队列到交换器（传入队列名、交换器名、路由键） 创建消费者对象（传入通道对象）并重写处理方法handleDelivery（）对消息进行处理确认等 渠道对象消费消息并向服务器进行应答 分为以下两种 /* autoAck为true时应答服务器，消息就会从队列中立即删除，不再往其他Consumer转发,如果不设置ack确认，RabbitMQ会认为消息没有被正常消费，消息会重新进入队列中。 被动消费模式 channel.basicConsume(String queueName, Boolean autoAck,Consumer callback); 主动消费模式 GetResponse response = channel.basicGet(Sring queueName,Boolean true); 消息队列是一种应用间的异步协作机制 消息Message由消息头和消息体组成，消息头包括：路由键、优先权、持久性存储等属性。 网络连接Connection网络连接，比如TCP连接 信道Channel是进行路由工作的实体，负责按照routing_key将message传输给queue，建立和销毁TCP连接都是很昂贵的开销，所以引入信道，它是独立的双向数据流通道，一个连接中可有多个信道，发送消息、接收消息、订阅队列都是通过信道完成的，每条TCP连接上可以有无数条信道，每个channel都有唯一对应的ID，一个channel只能单独由一个线程使用，在channel上的message是有序的 channel.getNextPublishSeqNo(); 在确认模式下，返回要发布的下一条消息的序列号 交换机Exchange用来接收生产者发送的消息并且路由给服务器中的队列，内部实现为保存binding关系的查找表 消息队列Queue用来保存消息，直到被消费者消费掉，具有自己的Erlang进程 生产者producer向交换机发布消息的应用程序 消费者Consumer从一个消息队列中取得消息的应用程序 应答确认Ack机制（acknowledged 确认）应答后，队列就把这条消息删除了，释放队列的内存空间 手动确认channel.basicQos(1); // 限制发送给当前消费者消息的数量为1，默认为0表示不限制在接收到Consumer的ack前，服务器不会将新的Message分发给它 ，不设置的话服务器会均匀分配给每个消费者一些消息，设置了的话则每次分给一个消费者一条消息，这样所有消费者运行完后，运行快的消费者会比运行慢的消费者多消费消息，达到能者多劳。 channel.basicAck(deliveryTag,false);参数2：如果为true，则确认所有消息（包括提供的传递标记）；如果为false，则仅确认提供的传递标记。 重新放入队列消费（long deliveryTag, boolean multiple, boolean requeue）channel.basicNack(deliveryTag,false,true); multiple为true时，拒绝标记之前的所有消息，为false时只拒绝当前标记的消息 channel.basicReject(deliveryTag,true); 相对于basicNack只少了multiple 抛弃此条消息channel.basicNack(deliveryTag,false,false); 生产者把消息发给虚拟主机 交换机的featuresD durable: true译为耐用的表示存储在磁盘I internal: true ###@RabbitListener(queuesToDeclare = “smsQueue”)相当于@RabbitListener (queueToDeclare = @Queue(value = “smsQueue”, durable = “true”, exclusive = “false”, autoDelete = “false”)) //默认为 持久化、非独占、非自动删除 topic订阅模式/动态路由routingKey中*代表一个单词，#代表一个或多个单词 方法上写上监听注解1234567891011@RabbitListener( bindings = &#123; @QueueBinding( value = @Queue, //此时不声明队列的value则会创建一个临时队列 key = &#123;"user.#","order.*"&#125;, exchange = @Exchange( type = "topic", name = "topicTest1" ) ) &#125; ) RabbitMQ的集群普通集群队列只保存在master结点，其他结点存了MQ的Exchange所有信息（除队列外），消费者可以在任意结点获取队列信息进行消费 镜像集群负载均衡器LVSinterview相关使用RabbitMQ有什么好处 解耦 A调用系统B和C，如果加入系统D，还需要修改A的代码，用上消息队列A作为生产者发送消息给队列，B、C、D等消费者直接消费即可 异步 非必要的业务异步进行，加快响应速度 削峰 并发量大时所有请求直接访问数据库，可能会造成数据库异常 broker、cluster？brokercluster 消息如何分发的？队列的消息轮询(round-robin)发送给消费者，每条消息只会分发给一个订阅的消费者(前提是消费者正确处理消息并确认) 消息是怎么路由的？生产者将消息发布到交换器上，消息创建时会获得一个路由键通过路由键可以把队列绑定到交换器上，消息到达交换器后，RabbitMQ会将消息的路由键和队列的路由键相匹配，消息会投递到相应队列中。 交换器类型direct：路由键完全匹配，消息就投递到相应队列fanout: 交换器收到消息广播到所有绑定的队列上topic：可用通配符匹配相应的路由键 channel.BasicQos(0, 1, false);在接收到Consumer的ack前，RabbitMQ不会将新的Message分发给它 如何保证消息最大程度的不丢失并且被正确消费？ 生产者确认 将信道设置为确认模式，则信道上发布的消息就会指派一个唯一的ID（从1开始），消息被发送到RabbitMQ服务器后， 服务器就会发送一个确认（Basic.Ack）给生产者，包括消息的唯一ID， 消息丢失的话会发送一个（Basic.Nack），生产者可以在回调方法中处理Nack指令 事务channel.txSelect(); //将当前信道设置为事务模式channel.txCommit(); //事务提交channel.Rollback(); //事务回滚影响性能，不建议使用 发送方确认 单条消息确认channel.confirmSelect(); 将信道设置成确认模式channel.waitForconfirms(); 等待发送消息的确认，消息发送成功则返回true，否则返回false 多条消息确认将消息放在缓存中，发送批量消息后调用waitforconfirms方法，返回为false则清空缓存重写发送所有消息 异步确认 （性能最好）渠道对象调用addConfirmListener方法传入ConfirmListener接口重写handleAck和handleNack方法 持久化 将队列标识为持久化，durable设为true; 将消息Message标识为持久化deliveryMode=2 消费者确认 自动确认改为在执行完业务之后在finally中手动确认，只有确认了，RabbitMQ才会把消息从队列中删除 如何避免消息重复投递或重复消费？RabbitMQ会对生产者发送的每条消息生成一个messageId，作为去重和幂等的依据 消费者消费后将messageId作为主键插入数据库中，消费前先判断数据库中有没有存在这条数据 将message存入redis作为消费记录，消费前先判断redis中有么有消费记录 死信队列哪种情况下会进入死信队列？ 消息被否定，并且requeue为false 消息在队列的存活时间超过设置的TTL时间 消息数量超过最大队列长度 如果配置了死信队列，则上面的消息会进入死信队列，否则被丢弃 如何配置死信队列？ 声明业务交换器、声明死信交换器 DEAD_LETTER_EXCHANGE 声明业务队列, 同时设置上业务队列的死信交换器和死信队列路由键参数, argument.put(“x-dead-letter-exchange”, DEAD_LETTER_EXCHANGE); argument.put(“x-dead-letter-routing-key”,DEAD_LETTER_QUEUEA_ROUTING_KEY);声明死信队列 将业务队列绑定到业务交换器上、将死信队列绑定到死信交换器上（同时设置上路由键DEAD_LETTER_QUEUEA_ROUTING_KEY） Map&lt;String, Object&gt; argument = new HashMap&lt;String, Object&gt;();// 统一设置队列中的所有消息的过期时间argument.put(“x-message-ttl”, 30000);// 设置超过多少毫秒没有消费者来访问队列，就删除队列的时间argument.put(“x-expires”, 20000);// 设置队列的最新的N条消息，如果超过N条，前面的消息将从队列中移除掉argument.put(“x-max-length”, 4);// 设置队列的内容的最大空间，超过该阈值就删除之前的消息argument.put(“x-max-length-bytes”, 1024);// 将删除的消息推送到指定的交换机，一般x-dead-letter-exchange和x-dead-letter-routing-key需要同时设置argument.put(“x-dead-letter-exchange”, “exchange.dead”);// 将删除的消息推送到指定的交换机对应的路由键argument.put(“x-dead-letter-routing-key”, “routingkey.dead”);// 设置消息的优先级，优先级大的优先被消费argument.put(“x-max-priority”, 10);channel.queueDeclare(QUEUE_NAME, false, false, false, argument); 幂等任意多次执行所产生的影响与执行一次的影响相同例如redis的set操作 RabbitMQ的底层架构原理，逻辑架构、物理架构以及数据持久化机制？你们RabbitMQ的最高峰QPS每秒是多少？线上如何部署的，部署了多少台机器，机器的配置如何？]]></content>
  </entry>
  <entry>
    <title><![CDATA[IO]]></title>
    <url>%2Funcategorized%2FIO%2F</url>
    <content type="text"><![CDATA[IO 输入输出流StringReader extends ReaderStringWriter extends Writer 操作数据源为字符串的字符流 字符流Reader InputStreamReader ， BufferedReaderWriter OutputStreamWriter ， BuferedWrite 字节流InputStream OutputStream 区别：字符流单元是两个字节的Unicode字符，字节流单元是一个字节；字符流以字符或字符数组的形式读写数据，只能读写二进制文件，字节流能读写各种类型的数据。音频、图片最好用字节流，避免数据丢失，关系到中文最好用字符流。 字节输入流转字符输入流：通过适配器模式，用InputStreamReader实现，该类构造器可以传入InputStream对象，字节输出流转字符输出流，用OutputStreamWriter。 同步VS异步同步I/O：每个请求串行执行，会造成阻塞，用户线程发起I/O请求后需要等待或轮询内核I/O操作完成后才能继续执行。 能够保证程序的可靠性异步I/O：多个请求并发执行，用户线程发起I/O请求后可以继续执行，当内核I/O操作完成后会通知用户线程，或调用用户线程注册的回调函数。 能够提高程序的性能 着重于是否是否等待任务完成后再继续进行 阻塞VS非阻塞阻塞：请求发出后，所需要的操作条件不满足时，请求一直阻塞，不会返回，知道满足为止。非阻塞：请求发出后，所需要的操作条件不满足时，立即返回一个标识信息告知条件不满足，而不会一直等待，一般需要循环判断请求条件是否满足来获取请求结果 着重于请求的条件不满足时是否等待 Unix下五种I/O模型 阻塞I/O分两个阶段： 等待数据就绪，网络IO是等待数据陆续到达，磁盘IO是等待磁盘数据从磁盘上读取到内核态内存 数据拷贝，出于安全，用户态程序无权限直接读取内核态内存，需要把内核态内存拷贝一份到用户态内存中 非阻塞I/O分三个阶段： socket设为NONBLOCK(非阻塞)，则请求的I/O无法完成时，返回一个错误码(EWOULDBLOCK)，这样请求就不会阻塞了 I/O操作函数不断地测试操作数据是否已经准备好，知道数据准备好为止，虽然I/O请求后立即返回了，但是仍需要不断的轮询、重复请求，消耗了大量的CPU资源 数据拷贝 很少直接只用此模式，但给I/O多路复用提供了条件 I/O多路复用用到了select或poll函数，这两个函数也会使线程阻塞，但可以同时阻塞多个I/O，实现了可以一个线程同时处理多个Channel的I/O请求 信号驱动I/O (Java不支持)socket允许信号驱动I/O，并安装一个信号处理函数，数据准备好后线程会收到一个SIGIO信号，调用信号处理函数进行数据处理 异步I/O前四个模型都是同步阻塞的。用aio_read 函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。所以异步I/O模式下，阶段1和阶段2(数据拷贝)全部由内核完成，完成不需要用户线程的参与。 Java中，NIO是非阻塞I/O，通过NIO实现的reactor模式是I/O多路复用的实现，通过AIO实现的Proactor模式是异步I/O的实现 reactor模式反应器模式（事件驱动模型），主要有两部分组成BOSS和WORK，BOSS就像老板，拉活、谈项目，然后下发到worker去处理。处理并发请求，如果有内容进来会自动通知我们，不必开启多个线程死等了。 IO和NIO的区别IO是阻塞的，调用read(),write()方法NIO是非阻塞，NIO中引入了缓冲区的概念，对数据的操作都是基于将数据移进、移出缓冲区 IO是面向流的，每次从流中(InputStream/OutputStream)读取一个或多个字节，直到取到所有字节NIO是面向缓冲的，数据会被读到一个缓冲区，可以在缓冲区前后移动处理，增加了处理过程的灵活性 NIO中有选择器，一个单独的线程监视多个通道，注册多个通道到一个选择器上NIO可以零拷贝，FileChannel拥有transferFrom和transferTo两个方法，可以将FileChannel的数据拷贝到另一个Channel，或者直接把另一个Channel数据拷贝到FileChannel，避免了传输数据时将源数据从内核态拷贝到内存态，再从内存态拷贝到目标内核态这两次上下文切换 Java中的I/O 磁盘操作：file 字节操作：InputStream、OutputStream 字符操作：Reader、Writer 对象操作：serializable 网络操作：Socket 新的IO： NIO 磁盘操作字节操作使用了装饰者模式，InputStream属于抽象组件，FileInputStream属于具体组件，FilterInputStream属于抽象装饰者，为组件提供额外的功能，如BufferedInputStream为FileInputStream提供缓存的功能 字符操作编码：字符–&gt;字节，byte bytes = str.getBytes(“UTF-8”);解码：字节–&gt;字符，String str = new String(bytes,”UTF-8”); OutputStreamWriter 字符流–&gt;字节流InputStreamReader 实现从字节流解码成字符流 对象操作序列化，即将对象转换成字节序列，方便存储和传输，ObjectOutputStream.writeObject();反序列化，ObjectInputStream.readObject(); 不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类状态 transient关键字，表示不能被序列化 网络操作Java中的网络支持：InetAddress：网络地址，即ipURL：统一资源定位符Socket：使用TCP协议实现网络通信。 通过InputStream和OutputStream进行输入输出Datagram：使用UDP协议实现网络通信。 DatagramSocket通信类，DatagramPacket数据包类 通道public interface Channel extends Closeable常用实现类：FileChannel：从文件中读写数据SocketChannel：通过TCP读写网络中的数据ServerSocketChannel：监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannelDatagramChannel：通过UDP读写网络中的数据 缓冲区不会对通道直接进行读写操作，而是依靠缓冲区public abstract class Buffer状态变量：1234567891011121314151617181920// mark &lt;= position &lt;= limit &lt;= capacityprivate int mark = -1; private int position = 0; //当前已读的字节数 private int limit; //还可以读的字节数 private int capacity; //最大容量public final Buffer flip() &#123; //切换读写 limit = position; position = 0; mark = -1; return this; &#125;public final Buffer clear() &#123; //清空缓冲区 position = 0; limit = capacity; mark = -1; return this; &#125; 实现类有：ByteBuffer，CharBuffer，ShortBuffer，IntBuffer，LongBuffer，DoubleBuffer，FloatBuffer 选择器 创建选择器 将通道注册到选择器上 监听事件 获取到达的事件 事件循环]]></content>
  </entry>
  <entry>
    <title><![CDATA[知行合一]]></title>
    <url>%2Funcategorized%2F%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80%2F</url>
    <content type="text"><![CDATA[知行合一 知行互相依靠推进，是一个环 第一步.过去(很久之前或1秒之前)的行–&gt;第二步.形成现在的知以及知之后的意识–&gt;第三步.马上要做出的行（马上要做出的行的同时也会变成第一步中的过去的行而又引起新的知，这是个环） 在第二步中形成的现在的知这种感觉只有过去的行才能改变，意识层面的空想99%都没用，想要摆脱(由过去的行引起的现在的知而又导致的将要做出的行)行，必须在舒适区做出新的行才可以，空想是没用的。 建立一个模型，一个一一对应，又不断被新的行所替代的模型 知，不是意识，是在接下来要做出的行之前的比意识更早的感觉，它发于瞬间，转瞬即逝。它来自于过去的行 不虑而知为良知(没有掺杂意识的知，意识中有“私欲”) 知行合一是规律，致良知是需要一生都要做的，去除”私欲“对自己的影响、让自己对知有更深层次的理解以提高对事物的认知水平就是致良知的过程，需要绝对的理性，没有人能绝对的摆脱私欲的影响，所以致良知是无止境的 “私欲”，不仅仅是个人错误的欲望，而是心理阴影、经验主义、主观想象的集合。私欲被包含在第二步的意识之中，在行动中意识到有哪些私欲，然后去掉它们。 王阳明不是创建了知行合一、心即理，而是发现了它们 心即理，无人教你如何孝敬父母，你内心自然知道该如何做，结果你做到了。这便是心即理、知行合一。此处的“知”(孝敬父母)是你知道的，且你的心里认为是对的，但有时你的“知”不一定是正确的，这便需要通过用你的“行”来更新替换”知“ 冥想可以有效去除“私欲”]]></content>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2Funcategorized%2Fgit%2F</url>
    <content type="text"><![CDATA[Git上游分支当前分支是从上游分支开出的新分支 master分支永存、无误、不可直接commit对应nfys.kinglian.cn develop分支上游：masterfeature分支和hotfix分支合并到develop永存、无误、不可直接commit feature分支上游：develop命名：feature/业务功能名称业务完成功能（测试无bug,产品要发布改业务）后，合并到develop test分支 全功能测试分支test/all： 上游：developfeature分支合并到test分支 部分功能测试分支直接使用feature/业务功能名称，部署该分支代码，运维对应不同的端口号 release分支上游：develop hotfix分支上游：master命名：hotfix/修复名称完成修复后，merge 到develop，然后merge到master并打tag push 被远程拒绝git pull git pull origin feature/placeMall_V1.0.08 git pull origin master –allow-unrelated-histories]]></content>
  </entry>
  <entry>
    <title><![CDATA[dom4j]]></title>
    <url>%2Funcategorized%2Fdom4j%2F</url>
    <content type="text"><![CDATA[dom4j开源xml解析包，把整个xml文档当成一个对象，把内容一次性装载进内存 xml转mapMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); SAXReader reader = new SAXReader(); InputStream ins = request.getInputStream(); Document doc = reader.read(ins); //获取根节点 Element root = doc.getRootElement(); List&lt;Element&gt; list = root.elements(); for (Element e : list) { map.put(e.getName(), e.getText()); } ins.close();]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2Funcategorized%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式工厂模式属于创建型模式，提供了一种创建对象的最佳方式，实现不同的条件下创建不同的实例 抽象工厂模式相当于超级工厂，用于创建其他工厂 单例模式懒汉模式 ：使用的时候再进行初始化，延迟加载 保证线程安全 防止指令重排 双重检查优化 1234567891011121314151617//声明对象的引用private static volition Singleton object = null;//私有化构造器private Singleton ()&#123;&#125;//返回对象实例private static Singleton getInstance()&#123; if(object == null)&#123; synchronized(Singleton.class)&#123; if(object == null)&#123; object = new Singleton(); &#125; &#125; &#125; return object;&#125; 饿汉模式 ：线程安全12345678910//声明对象的引用private static Singleton object = new Singleton();//私有化构造器private Singleton ()&#123;&#125;//返回对象实例private static Singleton getInstance()&#123; return object;&#125; 模板方法模式 抽象类中有基本方法和模板方法，模板方法中调用了一至多个基本方法，模板方法一般由final修饰 继承了该抽象类的子类实现其基本方法 1 代理模式扩展目标对象的功能，可以在目标对象的某个方法执行前后增加一些自定义的操作 静态代理 定义一个接口及其实现类 SmsService、SmsServiceImpl 定义一个代理类同样实现这个接口 SmsProxy 将目标对象注入进代理类 12SmsService smsService = new SmsServiceImpl();SmsProxy smsProxy = new SmsProxy(smsService); JDK动态代理从JVM角度，动态代理是运行时动态生成类字节码，并加载到JVM 定义接口及其实现类 创建JDK动态代理类，实现InvocationHandler接口并重写invoke方法，在invoke方法实现其他自定义操作逻辑 通过Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h);创建代理对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//接口public interface SmsService &#123; String send(String message);&#125;//接口实现类public class SmsServiceImpl implements SmsService &#123; @Override public String send(String message) &#123; System.out.println(message); return message; &#125;&#125;//JDK动态代理类public class SmsInvocationHandler implements InvocationHandler &#123; private final Object target; public SmsInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("方法调用前的自定义操作"); Object result = method.invoke(target,args); System.out.println("方法调用后的自定义操作"); return result; &#125;&#125;//用来获取被代理对象的工厂类public class JdkProxyFactory &#123; public static Object createProxy(Object target)&#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), //目标类的类加载 target.getClass().getInterfaces(), //接口代理类要实现的接口列表 new SmsInvocationHandler(target) //代理对象对应的（实现了InvocationHandler接口的）代理类 ); &#125;&#125;//实际使用SmsService smsService = (SmsService) JdkProxyFactory.createProxy(new SmsServiceImpl());smsService.send("发送成功"); cglib动态代理可以在运行期扩展Java类和实现Java接口，底层实现是通过ASM字节码处理框架来转换字节码并生成新的class（被代理类的子类）；速度上比jdk动态代理要快。CGLIB 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。 静态VS动态 静态代理的接口一旦新增方法，实现类和代理对象都必须修改，而动态代理无需修改代理类，降低了耦合度静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。 JDK动态代理 VS cglib动态代理 JDK动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类 迭代器模式在容器中用到的， 适配器模式装饰者模式装饰者和被装饰者可以独立发展，不互相耦合，装饰模式是继承的一个替代模式，可以动态实现扩展一个实现类的功能]]></content>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2Funcategorized%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质： 性质1：每个节点要么是黑色，要么是红色。性质2：根节点是黑色。性质3：每个叶子节点（NIL）是黑色。性质4：每个红色结点的两个子结点一定都是黑色。性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。]]></content>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2Funcategorized%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java并发包 java.util.concurrent接口BlockingQueue、Interface Callable、Interface ConcurrentMap&lt;K,V&gt;、ExecutorService、Future、RunnableFuture、FutureTask、RejectedExecutionHandler、ThreadFactory 类ConcurrentHashMap&lt;K,V&gt;、Executors、LinkedBlockingQueue、ThreadPoolExecutor 枚举TimeUnit 异常RejectedExecutionException volatile保证了可见性，禁止指令重排序，即使多线程之间，一个线程修改后其他线程也能感知变化，但不是能保证原子性 每次对该关键字修饰的变量的操作，都会激发一次load and save 操作，load：把值从主内存中加载到本地栈 ，完成操作后，再save保存到主内存中。volatile修饰的值被修改后，会使该值在其他所有工作内存中失效，其他线程再去操作就不再操作工作内存，直接操作主内存中的值，插入了内存屏障，保证处理器不乱序执行，所以它会降低一点性能。 并发存在的问题 共享 可变 Unsafe 魔术类可以绕过虚拟机，直接访问底层内存 ###state 状态，情况ReentrantLock 可重入锁 线程池为什么需要线程池？ 可以减少创建和销毁线程的次数，减少系统开销 可以根据系统情况调整线程的数量 可以根据项目控制并发的数量 几种线程池 newCachedThreadPool 可缓存线程池，可创建无限多的线程数，线程数量超过处理需要，可灵活回收空闲线程 newFixedThreadPool 定长线程池，可控制线程最大并发数，超出数量则在队列中等待 newScheduledThreadPool 定长线程池，支持定时和周期性任物执行 newSingleThreadExecutor 单线程化的线程池，只会用一个工作线程执行，保证任务的执行顺序 新建一个线程池public interface ExecutorService extends Executorpublic abstract class AbstractExecutorService implements ExecutorServicepublic class ThreadPoolExecutor extends AbstractExecutorService ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(“xmpp-pool-%d”).build();ThreadPoolExecutor threadPool = new ThreadPoolExecutor(corePoolSize , maximumPoolSize , keepAliveTime , BlockingQueue , threadFactory); 线程池的实现原理线程池本质是个HashSet，关键技术：锁(Lock、CAS)，阻塞队列、HashSet(资源池) 线程池的几个参数int corePoolSize：线程池的基本大小，即没有任务需要执行时线程池的大小,线程的数量没有达到此值，则每来一个任务就会创建一个线程，直到达到此值再把任务放在队列中排队int maximumPoolSize：线程池中允许的最大线程数，当前运行数量poolSize不会超过该值long keepAliveTime：一个线程处在空闲状态的时间超过该值，就会因为超时而退出，0表示立刻终止TimeUnit unit: 时间粒度转换BlockingQueue workQueue：阻塞队列，新提交的任务放在里面ThreadFactory threadFactory: 线程工厂，用于管理线程，可设置线程名称、对线程分组管理、设置线程优先级RejectedExecutionHandler handler：饱和策略 新提交任务时处理流程当前线程数量没有达到线程池的基本大小（poolSize &lt; corePoolSize）时,会新增一个线程处理新提交的任务，达到基本大小时，会将新提交的任务提到阻塞队列排队等候处理。 属性：allowCoreThreadTimeOut线程池的属性，是否允许基本线程超时退出。ture表示超时没有任务执行，则线程（包括基本线程）退出。 线程池的方法：prestartAllCoreThreads()：提前创建并启动所有核心线程，使其处于等待工作的空闲状态getPoolSize(): 线程池中当前运行的线程数量execute(runable) ：异步执行任务，没有返回值，无法判断任务是否执行成功，任务是接口Runable的一个实例 功能相当于 new Thread(runable).start();但又不完全相同submit(): 提交需要返回值的任务，返回一个Future对象，Future对象调用get()方法可获得任务的返回值，且此时线程会阻塞，直到get方法完成后才继续后面的任务shutdown(): 关闭线程池，原理是关闭线程的工作栈，逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。 （线程池的状态设为SHUTWDOWN，正在执行的任务会执行下去，没有执行的任务则中断）shutdownnow: 线程池的任务设为STOP，正在执行的任务不再执行，立即停止，没有执行的任务返回。 RejectedExecutionHandler饱和策略，当队列都满了并且线程池的线程数量达到了maximumPollSize，处于饱和状态，采取策略处理新提交的任务，默认是AbortPolicy AbortPolicy 直接抛出异常 CallerRunsPolicy 只用调用者所在线程处理任务 DiscardOldestPolicy 抛弃队列里最近的任务，来放置新提交的任务 DiscardPolicy 不处理，直接丢掉 这几个类都实现了RejectedExecutionHandler 并发编程主要解决两个问题 线程之间如何通信 ，主要是共享内存和消息传递 线程之间如何完成同步 上下文切换CPU不断的通过切换线程，每次切换时需要保存当前的状态，切换非常损耗性能 如何减少上下文切换 使用最少的线程 无锁并发编程，不同的线程处理不同段的数据 CAS算法，使用了乐观锁，可以有效的减少一部分不必要的锁竞争带来的上下文切换 在单线程实现多任务调度 如何避免死锁 避免一个线程同时获得多个锁 避免一个线程在锁内部占用多个资源，尽量保证一个线程占用一个资源 使用定时锁lock.tryLock(timeOut); 超时等待时当前线程不会阻塞 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况 同步 VS 异步同步：必须等待调用的方法结束后才能继续执行。 保证了程序的可靠性异步：调用B方法后，不用等待B方法结束，就可以继续执行，不论B是否完成。 提高了程序的性能 并行 VS 并发并行：多个CPU或机器同时执行一段逻辑并发：一个CPU通过调度算法执行多个线程，不是真正的同时，线程之间竞争CPU 阻塞 VS 非阻塞阻塞：当前线程挂起，等待需要的资源被其他线程释放非阻塞：没有线程会阻塞其他线程，所有线程都会尝试往前继续运行。 会提高CPU的利用率，但会增加线程切换的消耗 Thread、ThreadLocalMap、ThreadLocalThreadLocal是用来提供线程级别的变量，变量只对当前线程可见使线程间数据隔离，每个线程都有自己的变量副本。spring中使用ThreadLocal来设计TransactionSynchronizationManager类，实现了事务管理与数据访问服务的解耦，同时也保证了多线程环境下connection的线程安全问题 Thread中有个map，就是ThreadLocalMapThreadLocalMap是ThreadLocal的静态内部类，ThreadLocalMap的key是ThreadLocal类型，value是我们设定的(get、set方法)ThreadLocal是个弱引用，为null时会被垃圾回收调 当ThreadLocal是null时，但ThreadLocalMap生命周期和Thread的一样，它就不会被回收调，就会出现ThreadLocalMap的key没了，但value还在，出现内存泄露问题，解决办法：使用完ThreadLocal后，执行remove操作。 线程创建方式 继承Thread类，重写run方法 实现Runable接口，重写run方法 实现Callable接口，重写call方法 Runnable接口的run()方法和Callable接口的call()方法区别 run方法无返回值，call方法返回装载有返回结果的Future对象，Future对象调用get()方法可以获取该返回值 Future是接口，一般使用它的实现类Futuretaskpublic interface RunnableFuture extends Runnable , Futurepublic class FutureTask implements RunnableFuture 线程安全在并发的情况下，代码经过多线程调用，线程的调度顺序不影响结果则安全，即不会出现数据不一致或数据污染 当多个线程同时执行，多个线程之间是相互抢占资源执行，并且抢占是发生在线程的执行的每一步过程中，导致出现非法数据。这种现象就称之为多线程的并发安全问题。 死锁两个或两个以上线程持有各自所需要的锁，互相等待对方释放锁资源，形成无限等待。 阻塞队列BlockingQueue相当于队列Queue附加了两个操作 当队列为空时，线程会等待队列为非空 当队列满时，存储元素的线程会等待队列可用 线程的状态 就绪状态Runable当一个线程创建后，其他线程调用它的start方法，则此线程变为就绪状态，java虚拟机会为它创建方法栈和程序计数器，此状态的线程位于可运行池中，等待获取CPU的使用权 运行状态Running此状态的线程正在占用CPU，执行程序代码 阻塞状态Blocked此状态的线程停止运行，没有占用CPU，直到线程重新进入就绪状态，才有机会转到运行状态 阻塞状态分为3种 ： 1. 线程执行到某个对象的wait()方法 2. 线程试图获得某个对象的同步锁但该对象已被其他线程占用了lock() 3. 线程执行了sleep方法、或调用了其他线程的join()方法，或执行了I/O请求时 死亡状态 线程的run方法执行完毕，该线程的生命周期结束 未捕获的异常终止了run方法而使线程猝死 锁池 是同步环境下才有的概念，一个对象对应一个锁池 当前线程想调用对象A的同步方法时，发现对象A正在被别的线程占用，则当前线程进入锁池状态。锁池里放的都是想争夺对象锁的线程 当线程1被线程2唤醒时，线程1进入锁池状态，去争夺对象锁 start()和run()调用start()方法时，表示线程启动，并调用run方法，继续执行下面的方法，且无需等待run方法执行完毕。run()方法只是线程的一个普通方法，直接调用run方法要等待run方法执行完毕后才继续往下执行。 sleep()和wait()sleep会一直持有锁，通常用于暂停执行wait会释放锁，一般用于线程间的交互 sleep()和yield()sleep方法后，任何其他线程都可以进行竞争CPUyield方法只会给同优先级或更高优先级的线程运行的机会 //都是静态方法public static native void sleep(long millis) throws InterruptedException;public static native void yield(); interrupted()一个运行中的线程被其他线程调用该线程的此方法进行了中断操作 join()A线程中执行到了ThreadB.join(); 则A线程阻塞，但不释放对象锁，需要等待B线程执行完毕后才继续执行，如果等待超时，则到了超时时间，A继续往下执行 isAlive()线程方法 public final native boolean isAlive();线程是新建或死亡状态时返回false，运行或阻塞状态时返回true wait、notify、notifyAll方法wait(),notify(),notifyAll() 这三个方法都是对锁进行操作，java提供的锁是对象级的，而不是线程级的。 是final修饰的，无法被重写 都在同步代码块中调用 wait() 会立即释放对象锁，使当前对象处于等待状态。notify/notifyAll() 唤醒一个或多个处于等待状态（wait）的线程，用在wait之后 123456789101112131415161718synchronized(object)&#123; while(不满足当前条件)&#123; try&#123; //等待阻塞，释放当前的锁，让出CPU，进入等待状态。不继续做事情A了 object.wait(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println("现在被唤醒了"); &#125; //唤醒等待的线程，并不会立即释放锁,执行完代码块后再释放锁 object.notifyAll(); //开始继续做事情A&#125; 为什么用while而不用if用if的话，线程被重新唤醒，会继续执行wait之后的代码，此时的条件可能不满足了用while，线程被唤醒后会再进行判断循环条件，成立的话继续执行wait()后的代码，不成立的话执行while代码块之后的代码 守护线程为用户线程提供服务，比如GC线程线程对象在start()方法之前调用setDaemon(true);设为守护线程 程序执行完毕后，JVM会等待非守护线程执行完毕后关闭，而不会等待守护线程;且守护线程退出时不会执行finally块的代码 happens-before规则定义：1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。 8项规则： 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。 synchronized 阻塞式同步 可以保证同一时刻只有一个线程执行某个方法或某个代码块，同时可以保证一个线程的变化可见性(即可以替代volatile) 颗粒度：即可作用在以下下三个地方时： 静态方法，作用范围是整个静态方法，作用对象是类，即所有对象同一把锁 普通方法，作用范围是整个方法，作用的对象是调用这个方法的实例对象 代码块， 作用范围是{}里面的代码，作用对象是调用这段代码的实例对象 synchronized(Test.class){ //类对象 //do something;} synchronized(this){ //实例对象 //do something;} JUC java.util.concurrent 并发工具包包含两个子包： atomic、locks还有BlockingQueue、Executor、Future、Callable等 Lock相比Synchronized更灵活，可以显示加锁和释放锁，必须调用unlock方法释放锁，所以在finally块中释放锁，获取锁过程中能够响应中断，可以超时获取锁 AQSAbstractQueuedSynchronizer ，用于构建锁和同步机制的抽象类，子类有Sync有个属性 private volatile int state; state为0时表示锁没有人占用 ReentrantLock1234567Lock lock = new ReentrantLock();lock.lock(); try&#123; // do something&#125;finally&#123; lock.unlock();//在finally中释放锁&#125; 实现了Lock接口，加锁和解锁都需要显式写出 public class ReentrantLock implements Lock, java.io.Serializable 静态内部类有Sync、FairSync、NonFairSync，其中公平锁和非公平锁都继承了Sync 默认使用非公平锁 锁是可重入的（持有锁的线程可以继续持有，释放对等的次数后才真正释放该锁），每次lock都会让state加1，unlock后state就减1 tryLock(); 表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false 公平锁线程获取锁的顺序和调用lock的顺序一致，FIFO获取锁时，线程去竞争一个锁，可能成功或失败，成功的话直接持有资源，失败则进入队列阻塞，等待唤醒后再尝试竞争锁。 非公平锁线程获取锁的顺序是抢占式 monitor监视器（对象锁） Java中每个对象都有一个监视器，来监测并发代码的重入，在非多线程编码时monitor不起作用 执行同步代码块之前首先执行monitorenter指令获取对象的监视器monitor，退出时monitorexit指令，同一时刻只能有一个线程获取monitor 锁的重入性：同一个锁对象，线程不需要再次获取同一把锁，即monitorenter指令只会运行一次，而monitorexit指令可能会多次。每个对象拥有一个锁计数器，线程获取对象锁是该数加一，释放锁后减一 使用无界队列的线程池会导致内存飙升吗？线程池中线程的数量达到corePoolSize后，就开始向BlockingQueue队列堆积任务了，只要队列不满，就不会创建新的线程，就用不到maximumPollSize和KeepAliveTime了，如果线程处理的速度比进入队列的要慢，BlockingQueue就会越积越多，最后导致JVM OOM（内存溢出） 重排序为了提高性能，编译器和处理器常会对既定代码执行顺序进行指令重排序]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2Funcategorized%2FRedis%2F</url>
    <content type="text"><![CDATA[Redis默认端口号6379 丰富的数据类型Redis是key-value型数据库，key是字符串格式，value可以是String,Hash,List,Set,Sorted Set一个键能存512M的值 String使用场景； 用户访问次数、商品浏览次数、缓存频繁读取但不常修改的信息(值用json格式)、限定某个ip特定时间的访问次数、分布式session(session是以文件形式存在服务器中，用户在服务器A登录，下次却访问了服务器B，解决方式可以把session存在Redis中，Redis可以独立于所有负载均衡服务器，也可以放在一台服务器上) Hash使用场景： 某个属性需要频繁修改时。如购物车的商品信息，商品价格、销量等变化 List使用场景： 定时排行榜Lrange 返回列表中指定区间内的元素，相当于分页查找lrange key_name start end 0表示第一个元素，-1表示倒数第1个，-2表示倒数第2个 [start,end] Set使用场景： 音乐收藏夹列表 Sorted Set,即zSet，元素不允许重复，每个元素都关联了一个double类型的分数(score)，根据分数从小到大排序，分数可以重复，使用场景： 新歌榜、飙升榜 点击量作为score 内存存储 传统数据库是索引存下内存中，数据存在硬盘，数据是直接存在内存中的，是基于内存的而不是硬盘，读写速度非常快，所以被广泛应用于缓存方向 可持久化 把内存的数据保存在硬盘中，方便进行数据的备份和恢复 Redis的持久化将内存中的数据(如对象)保存到存储设备中(如磁盘) RDB默认方式(可自动触发bgsave和手动触发)按照一定的时间周期把内存的数据以快照的形式保存到硬盘的二进制文件。（二进制文件和文本文件都是按照二进制存储的，文本文件是把一个个字节解读成字符，二进制文件的输入输出省去了转换的过程）对应产生的数据文件为dump.rdb，可通过配置文件redis.conf中的save参数来定义保存周期，save 900 1 表示如果900秒内有1个key发生了变化(增、修、删)，则重写rdb文件，save””表示关闭自动触发 AOF 需要配置appendonly yes，默认不开启。默认文件名appendonly.aof将每一个收到的写命令通过write函数追加到文件最后，重启Redis后会根据内存的写命令在内存中重建整个数据库的内容。Redis还会对AOF文件进行后台重写，是的AOF文件不至于过大 两种方式同时开启时，优先执行AOF方式，因为AOF保存的要比RDB保存的完整 RDB优点：是紧凑的二进制文件，比较适合备份和全量复制，速度远快于AOF 缺点：无法实现实时或毫秒级持久化，新老版本无法兼容rdb文件AOF优点: 更好的保护数据不丢失，最多丢失一秒的数据，appen-only模式写入性能比较高，适合做灾难性的误删除紧急恢复 缺点：文件占用空间大，开启后会对QPS有影响，数据恢复比较慢不适合做冷备份(离线备份) 单线程的模型采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理 单线程的Redis为什么那么快 纯内存操作 单线程避免了频繁的上下文切换 采用了非阻塞IO，多路I/O复用机制 缓存雪崩原因：设置的缓存采用了相同的过期时间，同一时刻出现原有缓存过期；或缓存服务突然宕机了。 结果：（新缓存还没存入期间，）访问缓存的请求都直接去访问数据库了，对数据库的CPU和内存造成压力 解决办法： 加锁 ， 同缓存击穿 队列保证不会有大量的线程对数据库一次性进行读写 将缓存失效时间分散开，过期时间加上一个随机值 缓存穿透原因：数据库中不存在，缓存中也肯定不存在，但每次访问都会先访问缓存再访问数据库 结果：造成里两次无用的查询 解决办法：A. 采用布隆过滤器BloomFilter，将所有可能存在的数据哈希到一个足够大的bitmap中，一个不存在的数据会被这个bitmap拦截，从而避免了对数据库查询的压力B. 缓存空值，数据库中不存在的值，则在缓存中设为null，有查询当前key的请求时直接返回null（注意设置过期时间） 布隆过滤器：n个相互独立的哈希函数，解决哈希冲突，一个函数在bitmap中查询不到就说明不存在，只有全部函数都查到了才说明存在这个数据 两种方案可同时使用，先A过滤，再B缓存null 缓存击穿原因：一个key非常热点，这个key失效的瞬间，大并发穿破缓存直接访问数据库 结果：请求都直接去访问数据库了，对数据库的CPU和内存造成压力 解决办法：在访问key之前，采用SETNX（set if not exist），设置另一个短期key来锁住当前key的访问，访问结束后再删除该短期key，即在第一个查询数据的请求上采用一个互斥锁，没有查询到数据时锁住当前key，查询到以后，做缓存，再解锁 缓存预热在系统上线后将相关的缓存数据直接加载到缓存系统。这样可以直接查询事先被预热的缓存数据，避免用户在请求时先查询数据库再讲数据进行缓存。 缓存更新Redis有6中自带的缓存失效策略。 可定期清理过期的缓存 缺点：维护大量缓存的key比较麻烦 当有用户请求过来时再判断请求的缓存是否过期了，过期的话就从数据库中得到新数据并更新缓存 缺点：每次请求都要判断缓存是否失效，逻辑比较复杂 缓存降级非核心业务影响到核心性能，对其降级，目的是保证核心服务可用，即使是有损的 热点数据、冷数据缓存在失效前至少被访问了两次，这样缓存才有意义。要为访问频率比较高的热点数据建立缓存 事务 开启事务：MULTI 总是返回 OK 命令入队列：每次操作的命令都会加入到一个队列中，但此时命令不会执行 提交事务：EXEC 开始顺序执行队列中的命令 DISCARD清空事务队列并退出事务 WATCH监控一至多个key，一旦其中一个键被修改(删除)，之后的事务就不会执行了 UNWATCH取消对key的监视，执行DISCARD就不用执行这个了 发生命令执行错误Redis不会停止执行然后回滚数据的，所以不是Redis的事务不是原子性，为什么? 为了保证功能简化 ，运行速度更快 Redis的主从复制将一台redis服务器(主节点master)的数据复制到其他节点redis服务器中(从节点slave) 作用：数据冗余、故障恢复、负载均衡(读写分离、只由主节点负责写)、高可用基石(是哨兵和集群的基础) 实现原理： 连接建立阶段 ： 保存主节点信息: 从节点执行slaveof命令(异步)，维护masterhost、masterport两个字段，存储主节点的ip和port信息 建立socket连接：从节点每秒一次调用复制定时函数replicationCron(),创建socket连接，主节点accept后，为该socket创建相应的客户端状态 发送ping命令： 从节点发送ping命令检查socket是否可用，主节点是否能够处理请求，只有返回pong才说明正常 身份验证： 如果从节点设置里masterauth选项，则通过向主节点发送auth命令进行身份验证 发送从节点端口信息 ：从节点向主节点发送其监听的端口信息，主节点将该信息保存到从节点对应的客户端的slave_listening_port字段中 数据同步阶段： 从节点的数据初始化，从节点向主节点发送psync命令进行同步数据 命令传播阶段： 主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，保证主从数据一致性。是异步过程，所以延迟在所难免 Sentinel(哨兵模式)主从复制模式下，主节点发生问题需要手动将从节点晋升为主节点，还要通知客户端更新主节点地址Sentinel是一个管理多个Redis实例的工具，可实现对Redis的监控、通知、自动故障转移Sentinel创建时会从主节点上获取所有从节点的信息 心跳机制： Sentinel与Redis Node之间，Sentinel定时向主节点和从节点发送info命令获得其拓扑结构和状态信息 Sentinel与Sentinel之间，基于Redis的订阅发布功能，每个Sentinel节点会向主节点的Sentinel发送本节点对于主节点的判断以及当前Sentinel节点的信息 故障转移：Sentinel节点发现Redis主结点出现心跳检测超时时，判定为主观下线，数量达quorum个节点判定为主观下线则为客观下线(quorum = Sentinel节点总数量/2 + 1)，就会基于Raft算法选出一个领导者Sentinel进行故障转移故障转移步骤： （1）在从节点列表中选出一个节点作为新的主节点 过滤不健康或者不满足要求的节点； 选择 slave-priority（优先级）最高的从节点， 如果存在则返回， 不存在则继续； 选择复制偏移量最大的从节点 ， 如果存在则返回， 不存在则继续； 选择 runid 最小的从节点。（2）Sentinel 领导者节点会对选出来的从节点执行 slaveof no one 命令让其成为主节点。 （3）Sentinel 领导者节点会向剩余的从节点发送命令，让他们从新的主节点上复制数据。 （4）Sentinel 领导者会将原来的主节点更新为从节点， 并对其进行监控， 当其恢复后命令它去复制新的主节点。 Cluster(集群)实现了多节点同时写数据，采用无中心结构，每个节点都保存数据，节点之间相互连接从而知道整个集群状态 获取所有某个固定Pre前缀开头的key列表keys pre*执行此命令时会导致线程阻塞一段时间 scan命令可以无阻塞提取，但数据会有重复问题，可在客户端进行去重，而且整体所花费的时间会较长 Redisson是Redis官方Java版客户端 值是否带有双引号问题@Autowiredprivate RedisTemplate&lt;String,String&gt; redisTemplate; set和get的redisTemplate中应该用泛型保持一致 你说你用了Redis，那就会进一步问你，你哪个业务用了Redis？那个业务的流程请你叙述一下？ ● 在Redis里你们具体是选用了哪种数据结构存放什么数据？数据的过期时间是什么？如果缓存过期了，你的数据兜底方案是什么，到哪儿去回查？ ● 你的key如何设计的，为什么要这么设计？你的这个业务把数据放在了Redis里，是其他哪个业务来查Redis？为什么要这样子做？如果不用Redis会怎么样？]]></content>
  </entry>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2Funcategorized%2FJVM%2F</url>
    <content type="text"><![CDATA[JVM(Java Virtual Machine) 是运行Java字节码的虚拟机 类加载器子系统 将class文件装载到JVM运行时数据区中 运行时数据区（内存模型） 2.1 堆(Heap)： 线程共享，内存不连续，存储对象，一个JVM中只有一个堆 年轻代+老年代 堆默认600m，老年代占2/3内存。年轻代中又分为Eden：From Survivor: To Survivor = 8:1:1 jdk1.7后将运行时常量池从方法区移到了堆中 2.2 方法区（永久代）： 线程共享 （jdk1.8中，没有了方法区，而是用元空间metaspace替换，元空间不在虚拟机中，放在了本地内存。因为为永久代分配多少空间很难确定，超出指定空间容易造成内存泄漏） 常量、静态变量、类信息（类名、方法信息、字段属性信息）、编译器编译后的代码 2.3 栈(Stack)： 线程私有，内存连续，线程运行时会分配给该线程一块栈内存A，线程私有，该线程每运行一个方法都会创建一个栈帧，从A内存分配一块B内存给该方法 。 存放的一个个栈帧FILO先进后出 ，一个方法从调用到到执行完成就对应着一个栈帧在虚拟机栈中入栈到出栈的过程 局部变量表：基础类型时存局部变量的值，对象类型时存对象在堆中的内存地址（占用的空间大小在编译器时就确定了） 操作数栈：变量操作时暂存的数值 指向运行时常量池的引用： 方法运行时可能会用到类中的常量 方法返回地址：方法执行完毕后要返回调用它的地方 2.4 本地方法栈： 本地方法运行时需要的一块内存。 eg: native 修饰的方法是由C语言实现的，线程的start方法 2.5 程序计数器(Program Counter Register) 线程私有： 也称为PC寄存器，记录运行代码的位置，这样线程切换时可以在当前位置继续运行。 字节码执行引擎负责修改记录程序计数器的值 程序计数器存储的数据所占空间的大小不会程序的执行而发生改变，所以程序计数器不会出现内存溢出现象（唯一一个） 字节码执行引擎 执行class文件的字节码指令，相当于机器的CPU 类文件被编译成字节码文件后，JVM虚拟机通过类加载器子系统将其加载到数据区，再由字节码执行引擎去运行 GC，Garbage Collection垃圾收集回收垃圾对象（可达性分析后不可达的对象） 字节码扩展名是.class的文件，只是面向虚拟机的，因此Java程序无需重新编译就能在不同的操作系统上运行 HotSpot消耗大部分资源的只有那一小部分热点代码，JVM会根据代码被执行的情况收集信息进行优化，所以代码执行的次数越多，运行的速度越快 JDK和JREJRE是Java程序的运行环境，包括了JVM和Java类库JDK是Java Development Kit(Java开发工具)即Java SDK，它包括了JRE，还具有编译器javac和工具javadoc，能够创建和编译Java程序。 Java语言是编译和解释并存编译型：将源码全部一次性翻译成平台可识别的机器码解释型：一行一行的将源码翻译后机器码 Java编写程序需要先将Java文件编译成字节码文件，再由Java解释器来解释执行 Java语言的平台无关性Java编译器（javac.exe）生成字节码文件，JVM虚拟机负责运行字节码，把他交给解释器（java.exe）并操作解释器进行解释字节码文件为机器码。而JVM针对不同的系统会有特定的实现，能够保证相同的字节码都会得到相同的结果 内存泄露是指分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费。Java中一般不会产生内存泄露，因为有垃圾回收器自动回收垃圾，但这也不绝对，当我们new了对象，并保存了其引用，但是后面一直没用它，而垃圾回收器又不会去回收它，这边会造成内存泄露 内存溢出是指程序所需要的内存超出了系统所能分配的内存（包括动态扩展）的上限。 java内存模型(JMM) 主内存：是虚拟机内存中的一部分，所有的变量(此变量不是程序的变量)必须从主内存中产生。 工作内存：每个线程都有自己的工作内存，线程私有，工作内存保存了线程需要的变量在主内存中的副本，线程对主内存变量的修改必须在线程的工作内存中进行，不能直接读写主内存的变量，线程之间也不能互相访问工作内存。 数据原子操作 lock(锁定)Main ： 将主内存变量加锁，标识为线程独占内存 read(读取)Main ： 从主内存读取数据 load(载入)Work ： 将从主内存读取的数据载入工作内存 use(使用)Work ： 从工作内存读取数据来运行计算 assign(赋值)Work ： 将计算好的值重新赋值到工作内存中 store(存储)Work ： 将工作内存数据存到主内存 write(写入)Main ： 将store过去的变量值赋值给主内存的变量 unlock(解锁)Main ： 将主内存变量解锁，解锁后其他线程才可以锁定该变量 作用于主内存：Main作用于工作内存：Work]]></content>
  </entry>
  <entry>
    <title><![CDATA[高速隧道监控系统]]></title>
    <url>%2Funcategorized%2F%E9%AB%98%E9%80%9F%E9%9A%A7%E9%81%93%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[高速隧道监控系统fcs的项目属于物联网的一个开发项目 你的项目有多大，几个人开发？三人开发 主要分几个模块，开发周期是多长如何测试？三个月，tcp客户端模拟器测试 你负责哪个模块，模块内容是什么？你是如何实现的？tcp的服务端，用了Netty框架实现 在做程序的过程中碰到哪些问题，你是如何解决的？网络通讯状态不好时，数据包会断，处理粘包情况 如何保证代码质量的，需求文档和开发文档如何进行编写的？阅读需求文档，画流程图，类与类之间的关系，业务逻辑，进行代码评审，大家一起看看代码有什么问题。 这是一个偏向物联网的项目，它是用于控制高速隧道上的一些设备，比如交通信号灯，风机，车道指示器， 服务网关使用springboot和Netty网络框架，使用自定义netty组件进行消息解析和消息完整性分析处理,ctx链接管理，将设备上行指令转化为java可识别对象，使用市面通用标准基于TCP的modbus协议，规格化设备的上行指令。这些设备包括高速隧道的交通信号灯，车道指示器，风机等，将上行指令转化为java可识别的对象，通过位运算进制转换封装各类工具类，便于取出数据字段识别各字段的功能，数据字段包括事务处理标识符、设备地址码、功能码，数据长度、数据。设计模式方面使用了抽象工厂模式使代码业务分离，还有单例模式、适配器模式等，通过反射获取协议解析类。告警数据通过ActiveMQ透传至告警模块。 通信方式是ActiveMQ的点对点请求数据体是JSON格式的比如控制风机的转动，用动作指令标识符01表示正传，02表示倒转，03表示停止 设备控制接口，就是设备向服务器发送数据，参数有：请求类型、消息标识、设备类型、动作指令、ip地址。返回参数：应答类型、应答结果、消息标识、应答说明数据采集接口，服务器发送请求到设备，参数有：请求类型、消息标识、设备类型、ip地址。返回参数：请求类型、应答类型、应答结果、消息标识、设备类型、ip地址通过ActiveMQ定时获取设备状态信息：请求类型、消息标识、设备类型、ip地址、设备动作状态 通过在消息头中定义长度字段来标示消息的总长度,自定义解码器每次去指定数据的长度，解决TCP黏包问题 项目里面遇到过什么难点问题,怎么解决的?公司规模?我的公司规模大概200人左右，开发部门有3个，应用开发一部，开发二部，研发部。 每一个开发部门是大致再6-8人，主要有技术组长，3-4人开发人员，1个前端技术人员， 项目经理 你的个人规划是什么?你们项目中什么地方用到多线程？当面试官问你还有什么问题问我时，回答模式？贵公司开发用什么技术什么框架，或者利用什么公司 贵公司版本管理采用的事什么 git svn 贵公司的开发模式，是前后端分离还是后台人员需要开发js交互 贵公司的开发业务方向 你在上一个公司每天大概哪些事情-- 程序员得日常 1) 上班第一件事： 有时候有早会，统计以下进度或者安排任务 2) 开始日常工作： 把git服务器得代码更新下来 编码任务 -- 如果有需求和技术方面得问题就和上级沟通 改bug任务 -- 通过禅道系统和测试打交道 3) 加班： 开会，完成开发或者项目上线时需要随时待命 4) 下班之前： 提交自己得代码，写工作日志 设备风机、交通诱导灯、车道指示器、交通信号灯、车辆检测器 事务处理标识符（2）、协议标识符（2）、报文长度（2）、地址码（1）、功能码（1）、数据长度（1）、数据 aa aa 00 00 00 0d 01 a5 0a 00 00 00 00 00 01 00 00 00 01 {“ip”:”127.0.0.1”,”start”:21,”tccId”:1,”uuid”:”11ee1bd8516e4ae8a68bc43eb2bff0dd”,”value”:[2]}]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2Funcategorized%2FMySQL%2F</url>
    <content type="text"><![CDATA[默认端口号3306 类似于java中的if、else语句case 字段 when 值 then 结果 else 其他情况 endcase when 表达式（字段=值） then 结果 else 其他情况 end format（）format(100.234,2) 四舍五入取两位小数 结果为100.23 DISTINCT只能放在最前面，只会查出一个字段值select DISTINCT id，name 则只会查到id可用group by id 查出多个字段值 limitlimit 4 OFFSET 3等同于limit 3，4从第3个开始取4行 and 和 orand的优先级比or高，（）优先级更高，建议多用，没坏处 not 否定not in 正则表达式REGEXP用法如like 拼接 CONCAT（）取出空格整理数据Trim()函数去掉值左右两边的空格RTrim()去掉值右边的空格LTrim()去掉值左边的空格 select now()返回当前时间与日期 2019-11-09 15:46:07 Abs()返回一个数的绝对值 聚集函数AVG()平均数COUNT()某列的行数MAX()最大值MIN()最小值SUM()某列值之和 where后不能跟聚集函数因为where是对数据进行筛选，聚集函数是基于完整的所有数据进行计算 group byselectfromwhere 过滤行group byhaving 过滤分组order bylimit 组合查询UNION必须包含相同的列、表达式或聚集函数（查询的顺序可以不同,但类型必须相同，或可以隐式转换） UNION 和UNION ALLunion会自动去除重复的行，union all会返回所有的行（数据） UNION 的排序多个select语句进行union，只有最后一条语句中的order by才生效 函数timediff(a,b) 返回a-b的时间间隔，a和b表示日期或时间，必须格式一致 now() 返回当前日期时间curdate() 当前日期curtime() 当前时间 1、round(x,d) ，x指要处理的数，d是指保留几位小数 这里有个值得注意的地方是，d可以是负数，这时是指定小数点左边的d位整数位为0,同时小数位均为0； 2、round(x) ,其实就是round(x,0),也就是默认d为0； 全文本搜索 normal：普通索引 ; unique：唯一索引 ;fulltext：全文本索引;spatial：空间索引 要进行全文本搜索，必须索引被搜索的列 fulltext（） Match中的值必须和fulltext的一致，且次序一致1234select *from user//where Match(name) Against("zhangsan") 查询name中有zhangsan的数据//where Match(name) Against("zhangsan" with query expansion) 查询扩张，第一行有zhangsan和lisi 第二行有只有lisi，但第二行也能被查出来 插入数据insert into user (id , name , gender ,age ) value ( “1”,”张三”,1,”18”),(“2”,”李四”,0,”19”) 插入检索出的数据insert into user （id，name,gender,age) select id ,name ,gender ,age from user_new //并不要求两个表的列名相同 更新数据update user set age = “28” , gender = 0 where id = “1” 删除数据delete from user where id = “2” 如果要删除所有数据，truncate user （更快，因为不是逐条删除，实际是删除了此表又重新创建了） in和existin没有用到索引 select *from Awhere 1=1and exist （select 1 from B where 。。。） exist检测行的存在，返回的是true或false exist用于B表比A表数据大的情况 自动增长Auto_increment 每个表只允许一个自动增长列 select last_insert_id() 函数，返回最后一个Auto_increment的值 默认值插入列时default 指定默认值，不允许使用函数，只支持常量 重命名表rename table user to user_new 视图创建 create view shitu_name as select 。。。。。。 存储过程 创建create procedure procedure_name1()beginselect * from employee;end SQL语句后要有分号; 调用call procedure_name1() 删除drop procedure procedure_name1 有参的存储过程create procedure procedure_name2(in employee_id varchar , out employee_name varchar , out employee_age int)beginselect name into employee_name from employee where id = employee_id;select age into employee_age from employee where id = employee_id;end call procedure_name2(@employee_id, @employee_id , @employee_age) 事务MyISAM 不支持InnoDB 支持 MySQL数据库设计规范命名规范 命名有意义，一眼知道表、字段是干什么用的 表名、字段名均使用 小写字母，单词间以下划线“_”分割，如：“device_model”。 表名字段名长度禁止超过32个字符，为了统一规范，易于查询，超过的单词尽量可读缩略的形式进行书写 普通索引名称以 idx_ 开头，唯一索引以 uk_ 开头。 外键尽量以被引用表名称加 _id 组成，如：“device_id”。 临时库、表名必须以tmp为前缀，并以日期为后缀，如：“tmp_device” 备份库、表必须以bak为前缀，并以日期为后缀，如：“bak_device_20180611” 避免使用NULL字段，NULL字段很难查询优化，NULL字段的索引需要额外空间，NULL字段的复合索引无效 基础规范 统一使用 INNODB 存储引擎，除非某些特定原因再行商议。 表字符集统一使用 UTF8，如果emoji等表情符号的存储需求，可申请使用 UTF8MB4 字符集。 所有表、字段必须添加注释，id 可除外， type型(枚举)需指明主要值的含义，如”1 公开课，2 线上课”。 使用 timestamp 存储时间。 表必需指定主键，尽量采用自增方式。 不强制使用外键约束，此过程由业务端实现，提高性能。 能不用 NOT IN 就不用 NOT IN，会把空和NULL给查出来。 尽可能少的使用 TEXT、BLOB 类型。 单表数据量建议控制在5000W以内，超过的表必须考虑水平切分。 用 DECIMAL代替FLOAT和DOUBLE存储精确浮点数 禁止在数据库中存储明文密码，把密码加密后存储 注意limit分页效率。Limit越大，效率越低。可以改写limit，如：select id from t limit 10000, 10 改写为=&gt; select id from t where id &gt; 10000 limit 10 索引优化规范 对于复杂的查询，执行 explain，查看索引使用情况。 重要的 SQL 必须被索引，比如 UPDATE、DELETE 语句的 WHERE条件列 ORDER BY、GROUP BY、DISTINCT的字段。 不在低基数列上建立索引，例如“性别”。 如果是 索引字段，一定要定义为not null，因为 null 值会影响 cordinate 统计，影响优化器对索引的选择,不能保证有值，设置相应的默认值。 单表索引个数尽量限制在5个以内。 避免使大表的 JOIN。 最左前缀原则，mysql 使用联合索引时，从左向右匹配，遇到断开或者范围查询时，无法用到后续的索引列。 尽量减少直接使用 SELECT * 读取全部字段。 使用 like 模糊匹配，%不要放首位。 考虑适当的字段冗余，减少不必要的关联查询。 事务四大特性 原子性 一致性 隔离性 持久性 事务-隔离级别@Transactional(isolation = Isolation.DEFAULT)在B方法上声明 Isolation.DEFAULT 使用数据库的隔离级别 Isolation.READ_UNCOMMITTED 读未提交 最低的隔离级别，事务未提交前就可以被其他事务读取（会出现 脏读、不可重复读、幻读） Isolation.READ_COMMITTED 读已提交 一个事务提交后才能被其他事务读取 （会出现 不可重复读、幻读） SQL Server的默认级别 Isolation.REPEATABLE_READ 可重复读 保证多次读取同一数据时，其值都和开始时的数据一致，禁止读取到别的事务未提交的数据 （会出现幻读） MySQL的默认级别 Isolation.SERIALIZABLE 序列化 写会加写锁，读会加读锁，代价最高最可靠。 事务安全问题脏读：一个事务读取了另一个事务未提交的数据不可重复读：同一事务中，根据同一条件查询出的同一行记录的值不一致幻读：同一事务中，根据同一条件查询出的记录行数不一致 索引帮助快速获取数据的排好序的数据结构索引的建立就是对数据的排序的过程 二叉树最多有两个子节点左子结点元素&lt;父节点元素&lt;右子节点元素 满二叉树所有结点都有左右两个子节点，并且叶子都同一层。 完全二叉树按照层次给所有结点编号，编号是连续的 。 没有满二叉树完美，满二叉树也属于完全二叉树 二叉树的存储结构顺序存储结构用一维数组存储二叉树的结点，一般只用于存储完全二叉树。 链表存储结构数据域+指针域 int和bigintint 占4个字节，带符号范围 [-2^31,2^31-1]，无符号位[0,2^32-1]bigint 占8个字节，带符号位 [-2^63,2^63-1],无符号位[0,2^64-1] 推荐自增主键用 int unsigned类型MySQL中int(5)表示显示的宽度为5，但存放123456仍然能插入，默认宽度为11，指定zerofill则会补0 ###MySQL创建的B+Tree索引的根节点是常驻内存的，根节点中的指针域对应的数据在磁盘中。 存储引擎是形容数据表的 InnoDB （聚集）:用的较多 .frm文件：存放表结构信息.idb文件：存放数据和索引 ，存储了索引和当前索引字段和同行的其他字段的数据（叶结点包含了完整的数据记录） MyISAM :数据文件和索引文件是分离的（非聚集）.frm文件： 表结构信息.MYD文件： 数据.MYI文件： 索引 找到指定结点对应的数据指针位置，再从.myd文件中找到数据 聚集索引、非聚集索引聚集索引：数据行的物理顺序与列值(一般是主键的那一列)的逻辑顺序相同，一个表中只能有一个聚集索引。主键索引其实就是聚集索引非聚集索引：索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以有多个非聚集索引 行锁、表锁InnoDB：支持行锁和表锁，默认行锁MyISM：只支持表锁 行锁：开销小、加锁快、不会出现死锁、锁定粒度大、发生锁冲突的概率高、并发量最低表锁：开销大、加锁慢、会出现死锁、锁粒度小、发生锁冲突的概率小、并发度高 读写锁分为互斥锁和共享锁 互斥锁(排他锁)：事务对数据加了互斥锁后可读取、修改数据; 加了互斥锁后其他事务就不能再加任何锁了共享锁：事务对数据加了共享锁后只能读数据、不能写; 加了共享锁后其他事务还可以再加共享锁，但不能加互斥锁 primary key和second keyInnoDB中，主键索引的叶结点包含了完整的数据，非主键索引叶节点存的是主键的值 索引类型 b-tree hash 全局索引FULLTEXT R-Tree索引 b+tree相对于bTree优化了范围查找因为每个叶结点对应的数据段的第一个和最后一个都存了下一个数据块的指针，可直接顺着查找 MD5CSC16索引优化最左前缀原则 优化慢查询 - Explain字段含义 id 序列号，表示select子句的查询顺序 值不同时，值越大优先级越高，值相同时从上往下执行 select_type 查询类型 ， 区分普通查询、联合查询、子查询等类型 select简单查询，不包括子查询和union primary查询中包含任何复杂的子部分，最外层的查询就被标记为primary subquery select或where中包含子查询 derived from中包含子查询 union union后的第二个查询语句 union result 表示两个union的查询语句的查询结果，id为null table表示这一行的数据是关于哪张表的 type system 表示只有一行记录（系统表），是const的特例const 表示通过一次索引就找到了，用于比较主键（primary key）或唯一索引（unique）eq_ref 唯一性索引扫描，对于索引键，表中只有一条记录与之匹配。ref 非唯一性索引扫描，range 检索指定范围的行，where后有between，&gt;,&lt;,in等index 只遍历索引树，索引文件比数据文件小all 从硬盘全盘扫描，最慢了 以上查找类型效率递减，一般达到range级别就好，最好达到ref级别 possible key 可能会用到的索引 key 真正用到的索引 为null表示没有用到索引 key_len 索引可能会使用的最大长度，通过建表时的长度定义计算而来 ref rows 查找的行数，有多少条符合的记录 extra select语句的执行顺序：from -&gt; on -&gt; join -&gt; where -&gt; group by -&gt; 聚合函数 -&gt; having -&gt; 计算所有的表达式 -&gt; select字段 -&gt; DISTINCT -&gt; order by对结果集进行排序每个步骤都会产生一个虚拟表，用作下一个步骤的输入 SQL注入恶意添加输入or “a”=”a” 时恒成立解决：用预编译语句 ？ ； mybatis中的mapper方式 # MySQL性能优化：① 当只要一行数据时，用limit 1；//找到一条结果后就停止搜索了② 数据库引擎：MyISAM ：适用于大量查询InnoDB ：支持“行锁”，写操作时很优秀，还支持事务③ 用not exists 代替 not innot exists 用到了连接中建立的索引的作用，not in 会和每条记录进行比较④ 尽量不采用不利于索引的操作，如 not in ， in ， is null，is not null ， &lt; &gt; 等⑤ limit基数比较大时，使用between andalter table tName add index(字段名)⑥ 某个字段总要拿来搜索，就为其建立索引索引可以提高select的效率，同时也降低了insert和update的效率，因为insert和update时可能会重建索引7.避免在where语句后进行null值判断 创建存储过程1234567891011121314151617181920create procedure pr_add( a int , b int ) begin declare c int ;if a is null then set a = 0;end if;if b is null then set b = 0;end if; set c = a + b;select c as sum;调用存储过程 call pro_add( 10 , 20 );触发器（实现级联更改）：create Trigger Tri_namebefore/after insert/update/deleteon tbl_name for each rowbegin 包含SQL语句的程序体end char和varchar char(n)固定长度、占用内存多但效率更高一点; varchar(n)可变的字符类型;都表示n个字符，注意是字符 char最大长度255个字符，varchar最大长度65535个字节 实际存储的是实际字符串+记录字符串长度的字节 TIMESTAMP和DATETIMEtimestamp：4个字节存储，只能存到2038年，跟时区有关datetime：8个字节存储，只是保留文本表示的日期和时间 一个字符所占字节数 编码方式 英文 中文 ASCII码 1 2 UTF-8 1 3 GBK 1 2 Unicode 2 2 InnoDB 引擎的四大特性是什么？ 插入缓存 二次写 自适应哈希索引 缓存池 count(列名)、count(1)、count(*)执行效果上： count(列名)：只包括列名那一列，统计结果时会忽略列值为null的计数 count(1)：忽略所有列，用1表示代码行，统计结果时不会忽略列值为null的计数 count(*)：包括了所有列，统计结果时不会忽略列值为null的计数 执行效率上： 列名为主键，count(列名)会比count(1)快 列名不为主键，count(1)会比count(列名)快 表中多个列并没有主键，count(1)比count(*)快 表中有主键，count(主键)执行效率最优 表中只有一个字段，count(*)最优 SQL优化查询语句： where后不要使用函数或表达式，或导致全表扫描而不能用索引where后尽量不要null判断、不要 !=或&lt;&gt;使用between and代替in尽量不用not in。或用not exists代替，not in后面(‘a’,’b’)里没有null时会查出非null的正常数据，(‘a’,’b’,null)里面有null时，会查不到数据select语句只需要查询一条记录时用 limit 1EXPLAIN 优化SELECT语句为搜索字段创建索引like ‘%abc%’不会走索引，而’abc%’会走索引不要直接使用select * 导致这全局扫描 设计表： 每一张表都设置ID属性对于枚举类型的值，最好用ENUM而不是VARCHAR，如性别、星期、类型字段设计尽量NOT NULL 其他： 拆分大的delete、insert语句]]></content>
  </entry>
  <entry>
    <title><![CDATA[WMS]]></title>
    <url>%2FJava%2FWMS%2F</url>
    <content type="text"><![CDATA[1001-1234561018-1234561019-10191021-123456 mainPage.jsp用于定义导航链接的部分 bootstrap中的class .navbar 设置nav元素为导航条组件 .navbar-default 控制颜色的属性，默认白 .navbar-inverse 控制颜色的属性，黑 .navbar-nav 设置ul为导航条组件内的列表元素 .navbar-right 设置导航条内元素向右对齐 .navbar-fixed-top 设置导航条组件固定到底部 role=”navigation” 可以增强访问性 .container-fuid 自适应屏幕宽度，即满屏显示 .navbar-header 指定div元素为导航条组件包括品牌图标及切换按钮 .navbar-brand 设置导航条组件内的品牌图标，默认放文字，但也可放图片。 .home 是什么类？ href=”javascript:void(0)” 表示让超链接去执行一个js函数，而不是跳转到一个地址，void(0)表示一个空的方法。与href=”#” 不同的是#包含了位置信息，默认锚点是#top,则会回到网页顶部.dropdown 下拉菜单,默认隐藏菜单，点击时会自动添加.open类，显示菜单项.dropdown-toggle 表明这是个下拉列表，data-toggle属性，表明了后面下拉数据的切换是为哪个class服务的，是和最外容器类名一致。 所有图标都需要一个基类和对应那个图标的类 下拉菜单（小三角） 下拉菜单项，是class为dropdown内的 .container-fuid 自适应布局 .row 表示行 .col 表示列 .col-xs-* 超小屏幕（&lt;768px)使用 .col-sm-* 小屏幕【768px&lt;=宽度&lt;=992px ） .col-md-* 中等屏幕【992,1200） .col-lg-* 大屏幕 大于1200px时使用 栅格系统会自动把每行row分为12列，col-md-2表示显示6个div，每个占2列 data-toggle=”collapse” 隐藏内容data-toggle=”collapse.in” 默认显示内容 AccountHandler.java中，返回一个包含4个字符的图形验证码，并将值设置到用户session中。 window.open(URL,name,specs,replace);打开一个新的浏览器窗口，或查找一个已命名的窗口。参数都可选 $.param()，序列化对象，返回字符串var param = {a:100,b:200};var str = $.param(param);console.log(str);结果为：a=100&amp;b=200 验证码 使用java.awt包，包含了绘制图形的方法 写一个生成验证码的工具类，里面写了个char数组，包含了26个英文字母和9和数字，我没有写0，以免混淆 在访问路径后面加入了时间戳，new Date().getTime() ,如果每次的路径一样，浏览器就会自动加载缓存，加上时间戳后访问的路径就不一样了 使用ImageServlet实时生成验证码图片 定义BufferedImage对象 获得Graphics对象 通过Random类产生随机验证码信息 使用Graphics绘制图片 使用ImageIO输出图片 校验验证码是否正确 获取页面的验证码 获取session中保存的验证码 比较验证码 返回校验结果 刷新验证码js写的点击事件，在url请求中加入新的时间戳，获取新的验证码（awt包中BufferedImage类得到验证码图片，字符串是用Random随机生成的，将字符串存在session中，用ImageIO对象将验证码图片输出。 验证是否登录用Shiro框架的工具类得到当前用户的subject对象，调用isAuthenticated方法，返回false则说明没有登录，执行login方法，跳转到login界面 注销登录用Shiro框架的工具类得到当前用户的subject对象，调用isAuthenticated方法，返回true则说明已经登录，执行logout方法，跳转到login界面 登录信息加密【（密码的MD5+用户ID）的MD5+验证码】的MD5加密 验证密码加密方式（数据库的密码+验证码）的MD5加密 默认保存到数据库中的密码（密码的MD5+用户ID）的MD5 未登录则跳转到login页面在配置文件SpringApplication.xml中,加入过滤器，设置权限，所有请求都设置成authc，即必须登录认证后才能访问。 输入框格式验证bootstrapValidator插件，只需要设置属性值，不能为空notEmpty的提醒信息message；输入的规则，用正则表达式 用户和角色关联自定义域的类中，在doGetAuthorizationInfo方法，角色表和用户-角色关联表连接查询出用户的角色，传参给SimpleAuthorizationInfo（）方法，返回AuthorizationInfo对象,它相当于当前登录用户所拥有的权限的集合。 角色和权限关联在jsp页面使用使用标签库，&lt;shiro: hasRole name=”systemAdmin”&gt;权限的url是配置在数据库中的，后台取出url信息，与请求信息对比，用户登陆后会被shiro的拦截器拦截，得到用户有哪些访问权限。 正常情况下URL路径的拦截设置如下: /admins/user/**=roles[“admin,guest”] 登出时间记录写用户Session监听器，当用户session注销时，记录用户账户登出的时间和用户信息，插入记录表中。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2Funcategorized%2FjQuery%2F</url>
    <content type="text"><![CDATA[1、通过id查找：var div=$(‘#abc’)2、通过tag查找：var ps = $(‘p’) 查找所有的结点3、通过class查找：var ps=$(“.red”)返回所有class包含red的结点多个class，则var ps=$( ‘.red.blue’)4、通过属性查找： var email = $(‘[name=email]’)var password = $(‘[type=password]’)按属性前缀查找：var email = $(‘[name^=ema]’)按属性后缀查找：var password = $(‘[type$=word]’)5、组合查找： ① var emailInput = $(‘input[name=email]’)② var ps = $(‘p.red’)6、多项选择器：① $(’p,div’) 查找 和标签② $(‘p.red,div.green’) 查找 和7、查找 在当前结点的子节点中查找 find( ) 在当前结点开始向上查找 parent( ) 当前结点的上一个元素 next（）、下一个元素prev（） 8、过滤 filter( ‘.red’) 只保留符合类是red的结点 Ajax的核心是通过XMLHttpRequest对象，使网页与服务器进行通信，获取非本页的内容，用于异步请求；Jsonp核心是动态添加&lt;script&gt;标签调用服务器提供的js脚本，用于跨域请求。Ajax也可以通过服务器代理解决跨域问题。 jQery对Ajax异步进行了封装，几种常用的方式：$.ajax , $.post , $.get , $.getJSON123456789101112131415$.ajax(&#123; //常用的参数 method //数据的提交方式，get或post url //数据的提交路径 async //是否支持异步，默认true data //需要提交的数据 dataType //服务器返回数据的类型，可指定HTML、xml、json、text success : function()&#123;&#125; //请求成功后的回调函数 error : functin()&#123;&#125; //请求失败后的回调函数&#125;);$.post(&#123; contentType //发送post请求的格式，可指定text/plain,application/json &#125;) $(document).ready(function(){ console.log(“hello”);});等同于$(function()){ console.log(“hello”);}); 12345678910111213bootstrapValidator插件API,使用前导入js文件bootstrapValidator.min.js//获取当前表单的验证状态var flag = $(formName).data("bootstrapValitor").isValid();//触发全部验证$(formName).data('bootstrapValidator').validate();//触发指定字段的验证$(formName).data(“bootstrapValidator”).validateField('fieldName');//重置表单所有验证规则$(formName).data("bootstrapValidator").resetForm(); JavaScript中数组的push方法，向数组的末尾添加一个或多个元素，并返回新的长度。 jQuery中$.each()方法的使用]]></content>
  </entry>
  <entry>
    <title><![CDATA[web.xml配置]]></title>
    <url>%2Funcategorized%2FwebXML%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在web.xml中配置Spring的配置文件applicationContext.xml,需要为其配置ContextLoaderListener监听器12345678&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; Spring提供ServletContextListener的一个实现类ContextLoaderListener监听器，启动tomcat容器时，该类的作用就是自动装载ApplicationContext的配置信息，如果没有设置contextConfigLocation的初始参数，则会使用默认WEB_INF路径下的application.xml文件。 ContextLoaderListener会读取这些xml文件产生的WebApplicationContext对象，然后将这些对象放置在ServletContext的属性里，这样我们只要可以得到Servlet就可以得到WebApplicationContext对象，并利用对象访问Spring容器管理的bean。 ps: web.xml中元素的加载顺序：context-param–&gt;listeners–&gt;filters–&gt;servlets(load on startup)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java8]]></title>
    <url>%2FJava%2Fjava8%2F</url>
    <content type="text"><![CDATA[Java8变量lambda表达式只能引用标记了final的外层局部变量，即不能lambda内部修改局部变量 双冒号 类名::静态方法 对象::实例方法 类名::new 后面没() 接口可以定义非抽象方法，但必须用default修饰 JDK1.8对hash算法的优化低16位融合了高16位和低16位的特征，避免了hash冲突 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);hash值先右移16位，在同原值异或 JDK1.8对寻址算法的优化与运算替代取模，提升性能之前是对数组长度取模 hash%length ，改为hash&amp;(length-1)要求数组长度length是2的n次方HashMap 默认的长度一定是 2 的指数幂，所以这一个等式 hash%length = hash&amp;(length-1) 针对 HashMap 是永远成立的 jdk1.8新特性 Lambda表达式，允许像对象一样传递匿名函数 Stream API,充分利用多核CPU，可以写出更简洁的代码 Date和Time API，使日期、时间更稳定、简单。 接口中可以有普通方法和静态方法，普通方法必须由default修饰，静态方法必须有方法体 重复注释，可以在一个类中多次使用同一个注释]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot]]></title>
    <url>%2FJava%2FSpring%20Boot%2F</url>
    <content type="text"><![CDATA[Spring BootSpring的子项目，简化的Spring繁琐的配置，实现了自动配置，提供了各种启动器 核心注解@SpringBootApplication 是启动类注解，主要包含了以下三种： @SpringBootConfiguration 组合了@Configuration注解，实现配置文件的功能 @EnableAutoConfiguration 打开或关闭自动配置的功能 @ComponentScan Spring组件扫描 Spring Boot自动配置的原理Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载。这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，例ServletWebServerFactoryAutoConfiguration类这些自动配置类能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，例ServerProperties类 （如何取?）XxxxProperties类是通过@ConfigurationProperties注解从全局配置文件中绑定属性到对应的bean上(即xxxProperties的bean)，xxxxAutoConfiguration类再通过@EnableConfigurationProperties注解将这些bean导入到Spring容器中 XxxxProperties类的含义是：封装配置文件中相关属性；XxxxAutoConfiguration类的含义是：自动配置类，目的是给容器中添加组件。 Spring Boot配置加载顺序(不确定) .properties文件 .yml 系统环境变量 命令行参数 Spring Boot是否可以使用xml文件？可以，但不建议，使用时用@ImportResource注解引入 Spring Boot的核心配置文件bootstrap.yml 由父ApplicationContext加载，优先于application.yml的加载，且属性配置不能被覆盖application.yml 由ApplicationContext加载，用于项目的自动化配置 Spring Profiles主要用来配置开发环境和生产环境spring.profiles.default 默认值，优先级低。当active没有配置时，使用此变量。spring.profiles.active 优先级高，指定当前容器使用哪个profile 例子spring: profiles: active: dev 如何实现 Spring Boot 应用程序的安全性？使用 spring-boot-starter-security 依赖项，添加安全配置类，配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法 Spring Boot中如何解决跨域问题在后端通过CORS(Cross-origin resource sharing)来解决跨域问题一个Http请求先走filter，到达Servlet后才进行拦截器的处理，把cors放在filter里，就可以优先于权限拦截器执行 Spring Boot的监视器Spring boot actuator 是 spring 启动框架中的重要功能之一 ，对项目进行检查和监控 SwaggerSwagger 是用于生成 RESTful Web 服务的可视化表示的工具，它使文档能够以与服务器相同的速度更新。 Spring Boot打包成的jar和普通的jarSpring Boot打包成的jar可以直接运行，java -jar xxx.jar，不能作为普通的jar被其他项目依赖普通jar解压后就是包名，Spring Boot的jar解压后/BOOT-INF/classess目录下才是我们的代码 Spring Boot如何进行异常处理@ControllerAdvice+@ExceptionHandler 例：1234567891011121314@Slf4j@RestControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(&#123;MaxUploadSizeExceededException.class&#125;) public ResponseEntity&lt;ApiResult&gt; maxUploadSizeExceededException(MaxUploadSizeExceededException e) &#123; if (null != e.getMessage()) &#123; if (e.getMessage().contains("The field file exceeds its maximum permitted size of 1048576 bytes.")) &#123; return new ResponseEntity&lt;&gt;(new ApiResult(null, -1, "上传的文件大小不能超过1MB!"), HttpStatus.PAYLOAD_TOO_LARGE); &#125; &#125; log.error("发生异常, e=&#123;&#125;", e.getMessage(), e); return new ResponseEntity&lt;&gt;(new ApiResult(e), HttpStatus.OK); &#125; Spring Boot分页spring-boot-starter-data-jpa可实现 微服务中如何实现Session共享将所有微服务的Session统一保存到Redis上，对Session读取操作时都去读取Redis的Session Spring Boot如何实现定时任务配置类上添加@EnableScheduling，然后在方法上添加@Scheduled(cron = “ 0 0 10,16 ?”)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud]]></title>
    <url>%2FJava%2FSpring%20Cloud%2F</url>
    <content type="text"><![CDATA[Spring Cloud核心组件1.Eureka 是微服务架构中的注册中心，专门负责服务的注册与发现。 Eureka Client组件： 每个服务中都有一个Eureka Client组件，负责将服务的信息注册到Eureka Server中，即告诉Eureka Server自己在哪台服务器上监听着哪个端口， Eureka Server： 是注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号。 各服务内的Eureka Client组件默认情况下，每隔30秒会发送一个请求到Eureka Server，来拉取最新有变化的服务信息。 心跳机制，Eureka每隔30发送一次心跳，通知Eureka Server，当前服务还活着 123456//代表内存注册表的类public abstract class AbstractInstanceRegistry implements InstanceRegistry &#123; private final ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt; &gt; &gt; registry = new ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt; &gt; &gt;();&#125;//ConcurrentHashMap中的key，是String类型，表示服务名称，比如"inventory-service"(库存服务)，value表示了一个服务的多个实例。 inventory-service可以有3个服务实例，每个实例部署在一台服务器上//Map中的key，也是String类型，表示服务实例的id，value中的类Lease的泛型InstanceInfo表示了服务实例的具体信息，包含了机器的主机名、ip地址、端口号等。Lease类里面维护了每个服务最近一次发送心跳的时间 多级缓存机制 避免同时读写内存造成的并发冲突问题拉取注册表时（即读） 首先从ReadOnlyCacheMap里查缓存的注册表， 若没有再从ReadWriteCacheMap缓存中的注册表， 还没有，就从内存中获取实际的注册表数据 注册表发生变更时（即写） 在内存中更新变更的注册表数据，同时过期掉ReadWriteCacheMap，（此过程不会影响ReadOnlyCacheMap提供别的服务读取注册表信息） 一段时间内（默认30秒），各服务拉取注册表会直接读取ReadOnlyCacheMap， 30秒后，Eureka发现ReadWriteCacheMap被清空了，就会清空ReadOnlyCacheMap中的缓存， 下次有服务拉取注册表时，会从内存中直接获取最新的数据，同时填充各个缓存。 2.Feign@FeignClient使用动态代理机制，根据@RequestMapping等注解，动态构造出要请求的服务的地址 3.RibbonRibbon会从Eureka Client获取对应的服务注册表，也就知道了所有的服务都部署在哪些机器上，在监听哪些端口号，然后轮询算法，均匀的把请求分发到各个机器上，实现负载均衡。 4.Hystrix是隔离、熔断、降级的框架隔离：创建多个线程池，不同的服务走不同的线程池，避免服务雪崩熔断：A服务调用B服务，B服务挂掉了，设置一段时间内请求B服务时直接返回，不必等待网络请求卡住无法响应。降级：熔断之后，可先记录一下要做的B服务（以便后续补充服务），即没完成本来的任务只能降级完成相对简单低级的任务。 5.Zuul微服务网关，负责网络路由，所有请求都往网关走，网关根据请求中的一些特征，将请求转发给后台的各个服务。好处很多，可以做统一的降级、限流、认证授权、安全等。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC]]></title>
    <url>%2FJava%2FSpringMVC%2F</url>
    <content type="text"><![CDATA[SpringMVC实现了MVC设计模式的请求驱动类型的轻量级框架，实现了把请求参数和业务对象绑定。 SpringMVC的流程 tomcat的工作线程将用户发送的请求转交给前端控制器DispatcherServlet 前端控制器DispatcherServlet接收到请求后调用处理器映射器HandlerMapping，请求获取处理器Handler 处理器映射器HandlerMapping根据url找到具体的处理器Handler，生成处理器对象以及处理器拦截器HandlerIntercepter（如果有则生成），一并返回给前端控制器DispatcherServlet 处理器映射器HandlerMapping调用处理器适配器HandlerAdapter 处理器适配器HandlerAdapter经过适配后调用具体的处理器Handler 处理器Handler执行完成返回ModelAndView 处理器适配器HandlerAdapter将ModelAndView返回给前端控制器DispatcherServlet 前端控制器DispatcherServlet将ModelAndView传给视图解析器ViewResolver 视图解析器ViewResolver解析后返回具体的View 前端控制器DispatcherServlet对View进行渲染视图（将模型数据填充到视图中） 视图对象View将渲染后的视图返回给前端控制器DispatcherServlet 前端控制器DispatcherServlet响应用户 SpringMVC和Struts2的区别 SpringMVC的入口是一个servlet，即前端控制器；Struts2入口是一个filter过滤器。 SpringMVC是基于方法开发的，一个url对应一个方法，请求参数传递到方法的形参，可以是单例也可以是多例（建议单例）；Struts2是基于类的，传递参数是通过类的属性，只能设计为多例。 SpringMVC通过参数解析器解析request的请求内容，并赋值给方法的形参，将数据和视图封装成ModelAndView对象，最后将ModelAndView对象中模型数据通过request域传输到页面；Struts2是通过值栈存储数据请求和响应的数据，通过OGNL存取数据。 SpringMVC的常用注解 @Controller 控制器的注解，不能用别的注解替代 @RequestMapping 用于映射请求的url @RequestParam GET和POST请求传的参数会自动转换赋值到@RequestParam 所注解的变量上，例：@RequestParam(value=”username”)String username @RequestBody 常用来处理Content-Type为application/json, application/xml的数据；用来接收前端传递（不能用GET请求）给后端的json字符串中的数据（请求体中的数据），将json数据转为Java对象。 @ResponseBody 将Controller下的方法返回的Java对象转换为json响应给客户 SpringMVC是怎么和AJAX交互的通过Jackson框架可以把直接转化成js可识别的json对象 加入Jackson.jar 配置json的映射 在接收Ajax的方法里面可以直接返回Object、List数据，但方法前要加上@ResponseBody注解 SpringMVC用什么对象从后台向前台传递数据通过ModelMap对象，可以在这个对象里面用put方法，把数据添加到里面，前台可以通过EL表达式取出]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kafka]]></title>
    <url>%2FJava%2FKafka%2F</url>
    <content type="text"><![CDATA[Kafka由多个broker组成，每个broker是一个节点；创建一个topic，这个topic会划分为多个partition，每个partition可以存在不同的broker上，每个partition就放一部分数据。天然的分布式消息队列，一个topic数据分散放在多个机器上，每个机器放一部分数据，Kafka 0.8之前，没有HA机制，如果共三台服务器的话一台蹦了，就会损失1/3的数据；有HA机制，副本机制，Leader、Follower]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[计算机网络http响应码 200 OK 客户端相应成功 301 Moved Permanently 代表永久性转移，会修改url地址 302 found 代表暂时性转移，不会修改url地址 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未授权 403 Forbidden 服务器收到请求，但拒绝提供服务 404 Not Found 请求的资源不存在 eg:输入了错误的url 500 Internal Server Error 服务器发生了不可预知的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能会恢复 forword和redirect forword是服务器行为，转发，地址栏不变，可共享request的数据，一般用于用户登录 redirect是客户端行为，重定向，地址栏改变，不可共享数据，一般用于用户注销 get和post get：把请求的数据附在url之后（即http协议头中），url和数据用?分隔，参数之间用&amp;相连；是form表单的默认提交方式，提交的数据会在浏览器显示出来；不可用于提交二进制数据，如上传文件；对数据大小有限制，最多1024字节； post：把请求的数据放在http包的包体中；比get方式安全性高 get比post速度要快些，在第三次握手时，post请求中浏览器会先发送post请求头，再发送数据，get请求会一并发送get请求头和数据；多数浏览器会将get请求的静态资源(数据不会)缓存起来，post不会，对安全性要求不高的查询数据建议用get请求 关于http,XMLHttpRequest,Ajax的关系http 是浏览器和web服务器交换数据的协议,规范XMLHttpRequest 是javascript的一个对象,是浏览器实现的一组api函数(方法),使用这些函数,浏览器再通过http协议请求和发送数据Ajax 不是一种技术,是综合多种技术实现交互的模式:用html+css展示页面&gt;使用XMLHttpRequest请求数据&gt;使用js操作dom TCP和UDP TCP是基于连接的，UDP是无连接的 TCP是基于字节流的，UDP是数据报文模式 TCP多用于对数据准确性比较高的网路服务如文件传输、邮件发送；UDP多用于要求速度比较快的网路服务，如网络视频、网络电话。 重视数据的安全用TCP，否则用更高效的UDP TCP心跳TCP是传输层协议TCP两端A、B建立连接，A断掉电源或拔掉网线，B不会收到通知TCP的建立连接（三次握手）和断开连接（四次挥手）是通过发送数据实现的。B端定时给A端发送数据来检测连接是否异常断开，这就是心跳，数据的内容无关紧要，是数据长度为0的心跳包。TCP协议中有一个KEEP_LIVE开关。两端都应该互相发送心跳。 TCP是面向连接的长连接：server端和client端建立连接后，不断开，进行报文发送和接收短连接：连接后，交易完毕后立即断开，长用于一对多，例如一个server对多个client TCP对传送的每个数据字节都进行编号，并请求接收方回传确认信息（ACK），一定时间内没收到确认信息，则重传。数据编码使接收方能够处理数据的失序和重复问题。没有接收方的流量控制，会因为接收缓冲区溢出而丢失大量数据重视数据的安全传出用TCP，否则用更高效的UDP TCP，基于流的传输，即无保护消息边界：发送三次数据包，只要接收到缓冲区大小比三个数据包总大小大就行，只要一次接收动作。所以TCP会出现粘包问题，即下一个包的头接着上一个包的尾。UDP，保护消息边界：发送三次数据包，UDP必须接收三次。 TCP的三次握手目的：建立TCP连接通道，确认双方都有收发数据的能力。 SYN：SYNchronization，请求建立连接，并且设定其序列号（seq）的初始值。FIN：希望断开连接。ACK：确认，一般置为1。SYN、ACK表示标志位，要么是1要么是0；seq、ack表示序号。 第一次握手：客户端发送SYN包(seq=x)到服务器，进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到SYN包，通过发送ACK(ack=x+1)确认客户的SYN，同时也发送一个自己的SYN(seq=y)包，即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 TCP的四次挥手目的：断开连接主动关闭方：A 被动关闭方：B 第一次挥手：A发送一个FIN，用于关闭A到B的数据传送，但此时A还可以接受数据。进入FIN_WAIT_1(终止等待)状态； 第二次挥手：B收到FIN后，发送确认报文ACK（序号为收到的序号+1，FIN也会占一个序号）给对方，此时进入CLOSE_WAIT（关闭等待）状态； 第三次挥手：B发送一个FIN，用于关闭B到A的数据传送，进入LAST-ACK（最后确认）状态，等待A确认（即等待接收A发送的ACK包）； 第四次挥手：A收到FIN后，发送一个ACK给B，进入TIME-WAIT（时间等待）状态，必须经过2MSL（最长报文段寿命）的时间后，当A撤销相应的TCB后，才进入CLOSED状态。B收到A发送的ACK，会立即进入CLOSE状态。 避免粘包1、由发送方引起的粘包，TCP提供了强制数据立即传送的操作指令push，而不必等缓冲区满。（影响效率）2、由接收方引起的粘包，优化程序设计，设置接收进程优先级。（频率较高时会来不及接收）3、由接收方引起的粘包，将一包数据按结构字段，人为控制分多次接收，然后合并。（效率较低，不适合实时应用）周全之策：接收方创建一段预处理线程，预处理数据，将粘连的包分开。 解决TCP无保护消息边界问题：1、发送固定长度的消息2、把消息的尺寸与消息一块发送3、使用特殊标记来区分消息间隔 封包给一段数据加个包头，这样数据包就分为包头+包尾两部分 Cookie和SessionHTTP是无状态协议，每次的后续请求需要前面的信息时都需要再把所有的信息重传，导致每次连接传送的数据量增大。于是，Cookie和Session应运而生 Cookie是服务器返回给客户端的特殊信息(在响应头Response Header中)，这些信息以文本文件的形式存在客户端，然后客户端每次向浏览器发送请求时都会带上这些信息(在请求头中Request Header) Session是通过服务器保存状态的，Java中是通过HttpServletRequest的getSession方法创建的，服务器创建Session的同时，会该Session生成一个唯一的SessionId，并将SessionId响应给客户端，客户端下次请求就带上SessionId，服务器根据SessionId找到相应的Session Cookie只能存储String类型的对象，Session可以存储任意类型的Java对象重要信息保存在Session（如登陆信息），需要保留的信息存在Cookie（如购物车）Session通过Cookie工作，Cookie传输的SessionID让Session知道这个客户端到底是谁 token，适用于项目级的前后端分离（前后端代码运行在不同的服务器下）请求登录时，token和sessionId原理相同，是对key和key对应的用户信息进行加密后的加密字符，登录成功后，会在响应主体中将{token：’字符串’}返回给客户端。客户端通过cookie、sessionStorage、localStorage都可以进行存储。再次请求时不会默认携带，需要在请求拦截器位置给请求头中添加认证字段Authorization携带token信息，服务器端就可以通过token信息查找用户登录状态。!Token.png](../image/计算机网络/token.png) WebSockets(应用层协议)一种计算机通信协议，和HTTP是两个完全不同的协议，WebSocket是利用HTTP进行握手，两者都是基于TCP连接的。WebSocket是一种持久化的协议，HTTP是非持久化的HTTP1.0中，请求是一个Request一个Response，1.1后，做了优化，有一个keep-alive，一个Http连接可以发送多个Request连接，接收多个Response。Http协议永远是这样，一个Request只能有一个Response，Response是被动的，不能主动发起。 WebSocket是一个双通道的连接，在同一个TCP连接上，既可以发又可以收消息 Ajax轮询：浏览器隔几秒发送一个请求，询问服务器是否有新信息。long pull：采用阻塞模型，客户端建立连接后，如果没有消息就一直不返回Response，直到有消息后返回，客户端接收到消息后马上再次建立连接，周而复始。 WebSocket缺点：一个HTTP/WebSocket连接要跨越千山万水、经过无数的路由器、防火墙转发过滤，最后才到终点，在这些中间结点中可能会以为一份连接在一段时间没有数据就等于失效，会自作主张的切断连接，但服务端和客户端又不会收到任何提示。解决：让浏览器和客户端能够发送ping/pong Frame以此来维持连接状态，Frame是一种特殊的数据包，只包含一些元数据 应用场景：即时聊天通信、多玩家游戏、在线协同编辑、实时数据流的拉取和推送、实时地理位置]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis]]></title>
    <url>%2FJava%2FMybatis%2F</url>
    <content type="text"><![CDATA[Mybatisforeach标签 and eil.account_id not in &lt;foreach collection=&quot;query.employeeList&quot; item=&quot;id&quot; index=&quot;index&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #{id} &lt;/foreach&gt; not in ()会报错，所以要对queryemployeeList判空 collection 传入的集合，list、array、自定义的参数（@Param(“query”) ）item 集合中迭代元素的别名index list和数组中，index表示元素的序号，map中表示key 。 可选open 代码的开始符号close 代码的结束符号separator 分隔符 in和existin没有用到索引 select *from Awhere 1=1and exist （select 1 from B where 。。。） exist检测行的存在，返回的是true或false exist用于B表比A表数据大的情况 if else&lt;choose&gt; &lt;when test=&quot;pushMethod != null and pushMethod !=&apos;&apos; &quot;&gt; and push_method = #{pushMethod} &lt;/when&gt; &lt;otherwise&gt; and (push_method =&apos;xmpp&apos; or push_method = &apos;jpush&apos;) &lt;/otherwise&gt; &lt;/choose&gt; leftselect CONCAT(LEFT(a.user_phone,3), ‘5个*’ , right(a.user_phone,3)) as userPhone collection标签&lt;resultMap id=&quot;userInfoForCall&quot; type=&quot;cn.kinglian.phoneportal.model.vo.UserInfoForCallVo&quot;&gt; &lt;result column=&quot;audit_diseases&quot; property=&quot;auditDiseases&quot;/&gt; &lt;collection property=&quot;tagsList&quot; column=&quot;{userId=id}&quot; ofType=&quot;list&quot; select=&quot;getTags&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getTags&quot; resultType=&quot;string&quot;&gt; select name from user_tags ut left join tags t on t.id = ut.tags_id where ut.user_id = #{userId} &lt;/select&gt; &lt;select id=&quot;getUserInfoForCall&quot; resultMap=&quot;userInfoForCall&quot; parameterType=&quot;string&quot;&gt; SELECT u.id, u.avatar, u.account, u.real_name, u.gender, u.age, u.create_time, u.sfzh FROM USER u WHERE u.deleted != 1 AND u.account_id = #{value} &lt;/select&gt; 延迟加载 VS 立即加载延迟加载：在真正需要数据时才发起查询，不用时不查询关联的数据，又叫做按需查询(懒加载)。多用于一对多、多对多，lazyLoadingEnabled属性设置，默认false立即加载：不管需不需要，只要调用方法，立即加载所有数据。多用于多对一、一对一，lazyLoadingEnabled属性设置，默认false 一级缓存、二级缓存一级缓存：是SQLSession级别的缓存，缓存的是对象，当SqlSession提交、关闭等其他更新数据库的操作后，一级缓存就会失效。默认开启二级缓存：是SQLSessionFactory级别的缓存，缓存中存储的是数据，命中二级缓存时，通过存储的数据构造成对象再返回。默认关闭查询顺序： 二级缓存-&gt;一级缓存-&gt;数据库数据]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2FJava%2FJavaInterview%2F</url>
    <content type="text"><![CDATA[Java基础byte最高位表示符号位，0正1负 范围[-128 ， 127]1000 0000 表示 -0 ，即 -1281111 1111 表示 – (2^6+2^5+2^4+2^3+2^2+2^1+2^0）= -1270111 1111 表示 2^6+2^5+2^4+2^3+2^2+2^1+2^0 = 127 无论位运算还是算数运算，都是先获得补码（原码取反再加一，前提符号位不变），再运算，再得到原码（补码取反再加一，前提符号位不变）12345&lt;&lt; n，左移，乘以2的n次方&gt;&gt; n，右移，除以2的n次方| 或 有1则1 ， &amp; 有0则0^ 异或 相同为0，不同为1&gt;&gt;&gt; 无符号右移，左边补0 面向对象的三（四）大特征封装、继承、多态。（抽象） 封装：就是对数据和数据操作进行封装，只对外界提供一个接口，封装可以提高代码的重用性和安全性。 继承：从已有的类中继承信息创建新的类，提高了代码的复用性，是多态的前提。 多态：分为两种： 编译时多态机制，是静态分派的: 同类中方法的重载。运行时多态机制，是动态分派的：子类中方法的重写。实现多态的前提就是父类的引用或接口的引用指向子类的对象，子类进行方法重写。 多态的好处多态可以实现同样的对象引用调用同样的方法做出不同的事情。具有可扩充性，增加新的子类不影响已经存在的类的结构。 虚拟机中是如何实现多态的通过动态绑定技术，在运行期间判断所引用对象的实际类型，根据实际类型调用对应的方法。 接口接口是一系列方法的声明，方法没有方法体，变量是public static final修饰的，方法默认是被public abstract修饰的。不能有构造方法接口需要被其他类实现，这些实现可以有不同的行为。 抽象类用abstract修饰的类，不能被实例化，可以有构造方法、抽象方法和非抽象方法。抽象类不一定有抽象方法，但有抽象方法的类一定是抽象类。 接口和抽象类的区别 不同点： 抽象类中可以有抽象方法和普通方法（没有方法体的方法称为抽象方法），接口中的方法全是抽象方法。抽象类中可以有构造方法，接口中没有。抽象类可以有普通成员变量，接口中没有。抽象类在代码实现上发挥作用，接口主要是定义项目模块之间的通信。一个类只能继承一个抽象类，一个接口可以被多个类实现。抽象类可以提供某些方法的部分代码的实现，接口不行，向一个抽象类加入一个新的非抽象方法时，它的所有子类都自动有了这个新方法，而接口不行，接口中加入了新方法，其实现类（非抽象类）必须重写这个新方法。 相同点： 都不能实例化对象，子类必须实现抽象类或者接口的全部抽象方法，否则子类也必须定义为抽象类。 重载、重写/覆盖 重载：参数列表不同（个数、顺序、类型），方法名相同，在同一类中。 重写/覆盖：参数列表相同，方法名相同，在子类中，子类的方法修饰符权限必须高于父类，抛出的异常必须比父类范围小。 父类的静态方法能否被子类重写？不能，重写只适用于实例方法，如果子类中有和父类相同签名的静态方法，子类这个方法就会被隐匿，子类只能调用父类的这个静态方法。 不可变对象指对象一旦创建就不能被改变，任何修改都会创建一个新的对象，如String，Integer等包装类。 静态变量和实例变量的区别 静态变量又称为类变量，存在于方法区，程序加载类的字节码时就会给静态变量分配空间，可以直接用类名调用。实例变量在创建实例对象时才被分配空间，实例变量本身存放在堆内存中（动态分配，速度慢），其引用存放在栈中（大小固定，速度快） Java创建对象的几种方式 采用new 通过反射 采用clone 通过序列化机制 其中new方式是耦合度最高的，尽量少用new创建对象。 序列化的实现将对象的内容进行流化： 类实现Serializeable接口，使用一个输出流（如FileOutputStream）构造一个ObjectOutputStream（对象流）对象，在使用ObjectOutPutStream对象的writeObject（Object obj）方法将对象写出。反序列化就是用输入流，用ObjectInputStream对象的readObject（ ）方法 switch中能否用String做参数jdk1.7之后可以。switch不能用在long上。 String s1=”ab”,String s2=”a”+”b”,String s3=”a”,String s4=”b”,s5=s3+s4,那么s2=s5返回什么？false，编译过程中，编译器会将s2优化为”ab”,会将其放置在常量池中，s5则是被创建在堆区，相当于s5=new String(“ab”);ps:Java中字符串的连接（+）实际上都是使用StringBuilder的append()方法，(+)本质上就是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象toString方法成String对象。String 底层就是个字符类型数组char[] 字符型常量char和字符串常量String的区别 形式上，字符常量单引号引起的一个字符，字符串常量是双引号引起的0至多个字符，char c = ‘a’; String s = “abc”; 含义上，字符常量是一个整型的Ascll值，而字符串常量代表的是字符串在内存中的地址 占内存大小上，字符常量占两个字节，字符串常量占0至多个字节 String 对象的intern()方法。intern()方法会首先从常量池中查找是否存在该常量值，如果常量池中不存在，则先在常量池中创建，如果已经存在则直接返回。 创建了几个对象 String str = new String(“abc”);创建了几个对象，常量池有abc字段是1个，常量池没有”abc”字段则是2个。 String str=“abc”;创建了几个对象（如果常量池里面已经有对象了就是0个。如果没有就是1个）; new String(“abc”).intern();创建了几个对象（如果常量池里面已经有该字符串对象了就是1个，如果没有就是两个） Java中==和equals()的区别？equals()和hashCode()的区别？为什么重写equals一定要重写HashCode？ ==是运算符，比较两个变量是否相等，equals()是Object类的方法，比较两个对象是否相等（默认的是比较两个对象的地址，和==结果一样。 hashCode()也是Object类的方法，返回一个哈希值，若两个对象的的equals()是相等的，那么调用hashCode()一定返回相同的哈希值；若equals()比较不相等，hashCode()不一定相等；hashCode()相等，equals()不一定相等；hashCode不等，equals()一定不等。ps:Java规范：使用equals()判断两个相等的对象，必须具有相等的equals()方法，所以重写equals()方法时，一定要重写hashCode()方法。将对象放入集合中先判断集合中是否有此对象的hashCode()，没有再equals()比较。hashCode来源于这个对象的内部地址转换成的整型值，比较两个对象是否相同之前会先比较HashCode是否相同，HashCode相同的话再用equals方法比较，HashCode不同则直接判断这两个对象不同，如果只是重写equals方法，可能会出现equals方法相同而HashCode不同，导致重写的equals方法就没有意义了 12345678// Effective中提供的重写hashcode方法@Overridepublic int hashCode() &#123; int result = name.hashCode(); result = 17 * result + sex.hashCode(); result = 17 * result + age.hashCode(); return result;&#125; a+=b 和 a=a+b+=会隐式强转结果类型。 short s1=10; s1=s1+1;错误，s1+1会将结果转为int类型 &amp;和&amp;&amp;&amp;是位操作，&amp;&amp;是逻辑运算符，&amp;&amp;具有短路特性。 内部类就像是独立的实体，提供了更好的封装，除了外围类，其他类都不能访问。 final、finalize、finally final修饰变量不可变，修饰类不能被继承，修饰方法不能被重写；final在构造函数中修饰变量，初始化一个对象并赋值给一个引用变量之前，final域会先被初始化；在获取一个对象的引用之后，再读取其final域的值如果修饰的是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。 finalize方法是Object对象的方法，是对象在被回收之前调用的 finally是与try、catch一起用于处理异常的，一定会执行 浅拷贝和深拷贝 浅拷贝只复制对象，而不复制对象中所引用的对象深拷贝会把对象和其所有引用的对象都复制一遍 static 静态变量 静态方法 如果方法的执行不依赖于类的变量和其他方法，最好设置为静态的，占用更小的空间 静态代码块（多用于初始化） 静态内部类 不能使用任何外围类的非static成员变量和方法。 静态导包 eg: import static java.lang.Math.*; 则此类中就可以用Math类的方法了 类不管构造多少对象，静态代码块只执行一次 单类构造对象执行顺序： 静态代码块 非静态代码块 构造方法 有父类的子类构造对象执行顺序 父类静态代码块 子类静态代码块 父类非静态代码块 父类无参构造方法 子类非静态代码块 子类无参构造方法 this用于表示本类对象的引用 super用于表示父类对象的引用子类构造方法的第一行默认调用了super()，如果第一行调用了其他构造方法，则会替代super() new Son(); 调用步骤 super(); Son();相当于 Father(); Son();new Son(name); 调用步骤 super(); Son(String name);相当于 Father(); //父类没有显式的写出无参构造则会报错 Son(String name); 如果子类重写的构造方法需要子类的无参构造方法，则必须在第一行写this(); this();相当于 Father(); Son(); 如果子类重写的构造方法需要父类的无参构造方法，则必须在第一行写super(); super();相当于 Father(); this(name);相当于 Father(); Son(String name); this和super是对象实例级别，static是类级别，this、super不能用在static中 使用什么类型表示价格？不是特别关心性能和内存，用BigDecimal对象，加减乘除操作分别为add(BigDecimal value)、substruct(BigDecimal value)、multiply(BigDecimal value)、divide(BigDecimal value)。 byte[]数组和String转换,并设置编码.getBytes(“UTF-8”);new String(b1,”UTF-8”); 可以将int转换成byte类型吗？可以，int是32位，byte是8位，强转会丢失高24位。 枚举 通过枚举实现的设计模式：单例模式、策略模式 异常 error：虚拟机相关的异常，如系统崩溃、内存不足、方法调用栈溢出 Exception： CheckedException编译时异常：用try/catch或throw、throws处理 RuntimeException运行时异常：java.lang.NullPointExcetion 空指针异常java.lang.ClassNotFoundExcetion 找不到指定的类java.lang.NumberFormatException 字符串转换数字异常java.lang.IndexOutOfBoundException 数组角标越界异常java.lang.ClassCastException 数据类型转换异常 throw 用在方法体内，抛出一个实例 throws 用在方法声明后，由该方法调用者处理异常，表示会出现一种异常的可能性 类的实例化顺序 父类的静态变量和静态代码块（书写顺序） 子类的静态变量和静态代码块（书写顺序） 父类的成员变量赋值 父类类的构造代码块 父类的构造方法 子类的构造代码块 子类的构造方法 关于JVM类加载器 BootStrap，启动类加载器/核心类加载器，有C++实现，加载JAVA_HOME/lib（eg:rt.jar) ExtClassLoader,扩展类加载器，加载JAVA_HOME/lib/ext 的jar包 APPclassLoader，应用程序加载器，负责用户类路径（ClassPath）配置下的类库 自定义类加载器 类加载器的双亲委派模型：一个类加载器收到类加载请求时，自己先不加载，将请求委托给父加载器处理，父加载器无法处理，继续向上请求，直到BootStrap加载器也无法加载，才尝试自己加载。拒绝修改java源码，保证了Java程序的稳定性。 JVM内存区域 线程共享：Heap堆、Method Area方法区 非线程共享：VM Stack虚拟机栈、Native Method Stack本地方法栈、Program Counter Register程序计数器 操作码（方法本身）：Stack操作数（局部变量）：基本类型保存在Stack；对象类型，引用地址保存在stack,内容保存在Heap中类变量（静态变量）：程序一加载就在Heap中分配内存，但将内存地址分配到stack中 栈通常比堆小 java中为什么会有GC机制 安全性 减少内存泄露 减少程序员工作量 GC主要回收的内存主要回收方法区和堆内存，这两个是程序运行期间动态创建的。 JVM运行时数据区主要包括5部分： 程序计数器（Program Counter Register） 虚拟机栈（VM Stack） 本地方法栈（Native Method Stack） 方法区（Method Area） 堆（Heap） Java中的GC什么时候回收垃圾？一个对象不存在任何引用时 如何判断一个对象是否应该被回收（即对象没有被引用）？ 引用计数法（存在互相引用而无法GC的问题） 对象可达性分析算法（常用） 垃圾回收算法 标记-清除 标记-复制 标记-整理 分代回收 简单解释一下垃圾回收Java中垃圾回收最基本的做法是分代回收，内存中的区域一般被划分为3个世代：年轻、年老、永久。对象根据存活时间保存在对应的世代中。 多线程进程和线程进程是程序运行和资源分配的基本单位线程是CPU调度和分派的基本单位 进程在执行过程中拥有独立的内存单元，而多个线程可以共享内存资源 守护线程守护线程为用户线程提供服务，eg:GC线程程序执行完毕，JVM会等待非守护线程运行完毕后关闭，而不会等待守护线程。 线程切换CPU控制权由一个正在运行的线程切换到另一个就绪并等待获取CPU执行权的线程 创建线程的方式 继承java.lang.Thread类 实现java.lang.Runnable接口第二种方式的优点：Java不支持多继承，实现接口后还可以再继承其他类；继承整个Thread类的开销更大 Thread类的start()方法和run()方法线程调用start()方法,表示此线程启动了，此时java虚拟机会调用此线程的run()方法；start()方法真正实现了多线程运行，而无需等待run()方法执行完毕而直接继续执行下面的代码。run()方法只是Thread的一个普通方法，只执行主线程这一个线程，而且要等待run()方法执行完毕，才继续执行下去，这样就达不到写线程的目的了。 怎么检测一个线程是否持有对象监视器？Thread类中的静态方法holdsLock(Object obj),当且仅当对象的监视器（即锁）被当前线程持有的时候才会返回true。 Runnable接口的run()方法和Callable接口的call()方法区别run方法无返回值，call方法可以返回装载有返回结果的Future对象，Future对象调用get()方法可以获得该返回值。两个方法结束后线程会自动结束； Future是个接口，因此可以使用它的实现类FutureTaskpublic interface RunnableFuture extends Runnable , Futurepublic class FutureTask implements RunnableFuture sleep()和wait()方法的区别 sleep()是Thread类的方法，wait()是Object类方法 调用sleep()方法，对象不会释放线程锁，wait()方法会释放对象锁 sleep()睡眠后不会让出系统资源，wait()会让其他线程占用CPU sleep(milliseconds)需要指定一个时间，时间一到自动唤醒，wait()方法配合notify()或notifyAll()使用;wait()和notify()方法必须在同步块中被调用，wait会立即释放锁，notify则会在同步块执行完了再释放。 为何wait(),notify(),notifyAll()方法不放在Thread类中？这三个方法都是对锁进行操作，Java提供的锁是对象级的，而不是线程级的，所以把他们定义在Object类中。 如何在两个线程间共享数据？共享对象即可，通过wait/notify/notifyAll、await/signal/signalAll进行唤醒和等待，阻塞队列BlockingQueue就是为共享数据设计的 如何正确使用wait()?12345synchronized (obj)&#123; while(条件不成立)&#123; obj.wait(); &#125;&#125; 线程局部变量ThreadLocal属于线程自身所有，每个Thread里面都维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，不在多个线程间共享，保证了线程的安全。 生产者消费者模型的作用 通过平衡生产者的生产能力和消费者的消费能力，提升系统的运行效率 解耦，使两者联系更少，独自发展不会受到双方的制约 写一个生产者消费者队列 使用阻塞队列实现1234567891011121314151617181920212223242526//生产者public class Producer implements Runnable &#123; private final BlockingQueue&lt;Integer&gt; queue; public Producer(BlockingQueue q)&#123; this.queue=q; &#125; @Override public void run()&#123; try&#123; while(true)&#123; Thread.sleep(1000); queue.put(produce()); &#125; &#125;catch (InterruptedException e)&#123; &#125; &#125; private int produce()&#123; int n = new Random().nextInt(10000); System.out.println("Thread:"+Thread.currentThread().getId()+"produce:"+n); return n; &#125;&#125; 123456789101112131415161718192021222324//消费者public class Consumer implements Runnable&#123; private final BlockingQueue&lt;Integer&gt; queue; public Consumer (BlockingQueue q)&#123; this.queue = q; &#125; @Override public void run()&#123; while(true)&#123; try()&#123; Thread.sleep(2000); consume(queue.take());//take()方法，取走queue里排在首位的对象 &#125;catch (InterruptedException e)&#123; &#125; &#125; &#125; private consume(Integer n)&#123; System.out.println("Thread:"+Thread.currentThread().getId +"consume:"+n); &#125;&#125; 123456789101112131415//测试public class Test()&#123; public static void main(String[] args)&#123; BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(100); Producer p = new Producer(queue); Consumer c1 = new Consumer(queue); Consumer c2 = new Consumer(queue); new Thread(p).start(); new Thread(c1).start(); new Thread(c2).start(); &#125;&#125; 使用wait-notify来实现12 为什么使用线程池？节省线程创建和销毁的开销，达到线程对象的重用，还可以根据项目控制并发的数量 Java中线程的调度算法抢占式，一个线程用完CPU之后，操作系统根据线程的优先级和线程饥饿情况，算出总的优先级，并分配给下一个时间片给某一个线程执行。 Thread.sleep(0)作用有时某个线程会一直获得CPU的控制权，这样可以手动触发一次操作系统重新分配时间片的操作，平衡CPU的控制权。 什么是CASCompare and Swap 比较-替换。内存值V，旧的预期值A，要修改后的值B。预期值A与内存值V相等时，将内存值修改为B，并返回true。CAS为了取到最新的值，应配合volatile变量，并不能保证原子性。 volatile变量 volatile变量是一种比synchronized更轻量级的同步机制。 对非volatile变量进行读写时，系统先从内存拷贝变量到CPU缓存中；对volatile变量，系统直接从内存中读取，跳过了CPU缓存这一步。 一个线程修改了volatile变量的值，volatile能保证新值能立即同步到主内存，以及每次使用前立即从主内存刷新。 内禁止CPU指令重排序（CPU指令重排序：CPU采用了允许将多条指令不按程序规定的顺序，分开发送各相应电路单元处理） 性能：读和普通变量几乎相同，写操作较慢（因为要在代码中插入内存屏障保证处理器不发生乱序执行） 乐观锁、悲观锁乐观锁：认为线程竞争不总是发生，不需要持有锁，但是在更新数据时要判断别人有没有修改数据，一般用CAS算法和版本号机制实现优点：提高了并发性能缺点：乐观锁只能保证一个共享变量的原子操作；CAS长时间不成功的话会一直自旋，给CPU带来很大开销悲观锁：总是认为线程会竞争，每次拿到数据都会上锁。 ConcurrentHashMap的并发度segment的大小：16，即最多可以16个线程操作ConcurrentHashMap ConcurrentHashMap jdk1.6中 采用分离锁的方式，没有对整个hash表进行锁定，而是局部锁定，不影响其他线程对hash表的其他地方进行访问 jdk1.8中 与1.6不同，它采用了乐观锁CAS算法，底层还是数组+链表-&gt;红黑树, 多线程开发良好的实践 给线程命名 考虑使用线程池 优先使用volatile变量 优先使用并发容器而非同步容器 线程通信用高层次的并发工具，如BlockingQueue，少用wait()、notify() 最小化同步范围 数组查找 时间复杂度O(1)插入、删除 涉及到元素的移动，时间复杂度为O(n) 创建数组的方式int[] arr = new int[6];int[] arr1 = new int[]{1,2,3,4,5,6};int[] arr2 = {1,2,3,4,5,6} 存入数据put通过对数据元素的hashCode值对容量取模（hashCode值 % 容量）来分配位置到数组，取模值相同则在数组的当前位置以链表结构形式继续存入 扩容扩容时，是用位运算，将旧数据元素分配位置，迁移到新数组 链表新增、删除 只需处理结点间的引用，时间复杂度为O(1)查找 需要遍历列表的所有结点逐一进行对比，复杂度为O(n) 集合.在java.util包中Java中集合及继承关系 集合分为两大类：Collection、Map Collection是一个个的存（Map是键值对的形式存）,Collection对象在调用remove、contains方法时会调用equals和hashCode方法，重写equals时必须重写hashCode方法。Collection继承了Iterable接口，有个iterator()方法，用于统一遍历元素，返回的Iterator对象，称为迭代器，可以方便的删除集合中的内容 Map 1.实现了Collection接口的集合List接口有序，元素可重复实现类有： LinkedList 基于链表，增删快，查询慢，非线程安全 ArrayList 基于数组，增删慢，查询快，非线程安全 Vector 基于数组，都慢，效率低，线程安全，增删改查方法都加了synchronized 来保证同步 CopyOnWriteArrayList，线程安全，只是在读、删方法上加了锁，适合读取多、修改少的数据写人数据时会将原数组内容copy到volatile修饰的成员变量数组中，修改操作的同时，读操作不会被阻塞，而是继续读取旧的数据 Set接口无序，元素不可重复，元素在集合的位置由元素的hashCode决定实现类有： HashSet 无序、不可重复。底层由HashMap实现，使用时要重写equals()方法和hashCode()方法 非线程安全 LinkedHashSet 继承于HashSet 非线程安全 TreeSet 有序、不可重复。底层红黑树 2.实现了Map接口的集合Map接口无序，Key不可重复、值可以实现类有： HashMap 基于hash表的Map接口实现，非线程安全，支持null键、null值HashMap的静态内部类 12345static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; 属性有 final int hash; final K key; V value; Node&lt;K,V&gt; next; 基于数组+链表的存储结构（数组中的每一项(map.Entry)存储的数据是个链表），数据hash值 &amp; (length-1) 得到该数据在数组中的位置;eg:每个数组元素存储的是链表的最后插入的数据A，A的index是0，则Entry[0]=A,此时又put了B，B的index也是0，则Entry[0]=B,B.next=A。数组默认容量16，加载因子0.75，即当存入12个元素后就进行扩容，扩容是新建一个长度为16*2的数组，选择0.75作为默认的加载因子，完全是时间和空间成本上寻求的一种折衷选择扩容后重新寻址rehash，遍历原entry数组重新hash到新数组中，原来的对象在新数组中的位置，要么在原下标的位置，要么在(原下标+原容量16)，位运算时数组长度是2的n次方（因为这样不同的key的hash计算结果相同的几率较低，减少hash碰撞，使得数据在数组上分布的比较均匀，查询的时候就不用遍历某个位置上的链表，可以提升定位元素的的效率）jdk1.8后链表长度大于阈值(8),链表会转为红黑树（时间复杂度从O(n)到O(logn)），转为红黑树之前判断，数组长度小于64则会先扩容jdk1.8后put或get方法操作链表时比1.7多了对是否存在树节点的判断 jdk7：数组+链表。数组的定义：Entry&lt;&gt;链表头插法：新增结点插在头部，实现简单，但插入的顺序和读取的顺序是相反的，并发下可能会死锁 12345678910111213hash值：使用hashCode的值，通过一定算法产生的hash值，如下方法final int hash(Object k) &#123; int h = 0; h ^= k.hashCode(); h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; 索引：static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; jdk8：数组+链表+红黑树。数组的定义：Bucket&lt;&gt; TreeCode&lt;&gt;链表长度超过一定阈值(8)时会转存为红黑树，尾插法：新增结点总是插在尾部，实现复杂，插入顺序与读取顺序一致 1234567hash值：使用hashCode的值，通过一定算法产生的hash值，如下方法static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;索引：hash值 &amp; (length-1)，删除了indexFor方法声明，直接用式子表示 LinkedHashMap HashMap的子类，有序 非线程安全 是基于HashMap和双向链表实现的，双向链表只是用于保证顺序 ConcurrentHashMap jdk1.8中，抛弃了jdk1.7的Segment(Segment继承了ReentrantLock)分段式锁，采用CAS+synchronized来保证线程安全，存储方式是数组+链表/红黑树，默认容量16，负载因子0.75 HashTable不支持null键、null值 线程安全，存储方式是数组+链表，链表主要是解决哈希冲突 TreeMap 红黑树,还实现了SortMap接口 HashMap和ArrayList的大小HashMap默认大小16个元素，扩容是原大小的2倍，加载因子0.75，如果传了初始值，会变成比当前值大的2的n次方的最小数ArrayList默认大小10个元素，扩容是原大小的1.5倍 NewLength = OldLength + OldLength &gt;&gt; 1 HashMap和WeekHashMap的区别WeekHashMap使用上和HashMap没有任何区别，只不过是使用了弱引用作为key，key对象没哟任何引用时，key/value就会被回收 poll()方法和remove()方法的区别两者都是从队列中取出一个元素，poll()方法取出元素失败时会返回null，remove()方法失败时会抛出异常 LinkedHashMap和PropertyQueue的区别LinkedHashMap遍历时根据元素插入的顺序，PropertyQueue是优先级队列，遍历时没有任何顺序保证 ArrayList和LinkedList的区别 ArrayList底层的数据结构是数组，查询时时间复杂度是O(1),较快 LinkedList底层是双向循环链表,查询时时间复杂度是O(n),比较慢 ArrayList和Array的区别Array可以容纳基本类型和对象，而ArrayList只能存放对象Array可以指定大小，而ArrayList的大小是固定的 ArrayList和CopyOnWriteArrayList的区别java.util.ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializablejava.util.concurrent.CopyOnWriteArrayList implements List, RandomAccess, Cloneable, java.io.Serializable ArrayList线程不安全，CopyOnWriteArrayList线程安全想要保证ArrayList线程安全，如果用synchronized或ReadWriteLock，写操作加锁后如果有大量读操作，会造成阻塞， 如何打印数组用Arrays.toString()方法或Arrays.deepToString()//数组中还有数组，深度打印 遍历ArrayList时如何正确移除特定值的元素 for循环遍历，使用ArrayList的remove()方法，移除了某个值后指针自动后移，for的条件又加一了，可能会忽略下一个符合条件的元素。可以再i–进行处理。 iterator迭代器遍历，使用iterator的remove()方法，next()指针逐个后移，建议使用。 HashMap 是线程不安全的 死锁（1.7版本之前会）或数据丢失 resize时的死循环及使用迭代器时fast-fail多线程扩容可能会死锁，如果当前位置有两个数据AB，其中一个线程新扩容存储顺序可能是AB，另一个线程是BA，造成死锁 遍历map集合 keySet()方法，返回Set集合 keySet,for(String key ：keySet){ key//key值} entrySet()方法，返回Set&lt;Entry&lt;Key,Value&gt;&gt;集合 entrySet,for(Entry&lt;Key,Value&gt; entry : entrySet){ entry.getKey //key值 entry.getValue //key对应的value值} Comparable java.lang.Comparable接口，只有一个方法compareTo()所有排序的类都实现了该接口public int compareTo(Object object);返回0，相等，返回正数，大于object，返回负数，小于object。 数组转集合 List list = Arrays.asList(“a”,”b”,”c”);最快的方式，返回的只是个视图，不需要多余的内存来创建list以及复制操作，不能进行增加、删除操作，可以用set（）方法修改，原数组也会跟着修改 Java8的Stream 包装类型Integer[] myArray = {1,2,3};List list = Arrays.stream(myArray).collect(Collectors.toList()); 基本类型int[] myArray2 = {1,2,3};List list2 = Arrays.stream(myArray2).boxed().collect(Collectors.toList()); Guava包 List il = ImmutableList.of(“string1”, “string2”); // from 可变参数List i2 = ImmutableList.copyOf(aStringArray); // from 数组 List l1 = Lists.newArrayList(anotherListOrCollection); // from 其他集合List l2 = Lists.newArrayList(aStringArray); // from 数组List l3 = Lists.newArrayList(“or”, “string”, “elements”); // from 可变参数 使用 Apache Commons CollectionsList list = new ArrayList();CollectionUtils.addAll(list, str); 使用 Java9 的 List.of()方法Integer[] array = {1, 2, 3};List list = List.of(array);System.out.println(list); / [1, 2, 3] // 不支持基本数据类型 / IO流两种不同操作单元的流 字符流：单元是两个字节的Unicode字符，以字符或字符数组的形式读写数据，只能读写二进制文件 Reader-&gt;InputStreamReader , BufferedReader Writer-&gt;OutputStreamWriter , BufferedWriter 字节流：单元是一个字节，你能读写各种类型的数据 InputStream OutputStream 字节输入流转字符输入流，通过适配器模式，用InputStreamReader实现，该类构造器可以传入InputStream对象；同样的字节输出流转字符输出流用OutputStreamWriter。 图片、音频的传输最好用字节流，涉及到中文的最好用字符流 IO线程模型 同步：需要主动读取数据，读写数据过程中还会阻塞； 能够保证程序的可靠性。 异步：只需要IO操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写； 能够提高程序的性能。 阻塞：CUP停下来等待这个线程完成后才继续运行。 非阻塞：CUP去做其他工作，当这个完成后再继续完成后续的操作；会提高CPU的利用率，但会增加线程切换的消耗。 BIO和NIO BIO，同步阻塞IO 服务器实现模式是一个连接对应一个线程，当客户端有连接请求时服务器就会启动一个线程进行处理，如果连接不做任何事就会造成不必要的开销，可用线程池优化。必须使用多线程是因为BIO通信模型涉及的三个主要函数socket.accept()、socket.read()、socket.write()都是同步阻塞的。 NIO，同步非阻塞IO 服务器实现模式是一个请求对应一个线程，客户端发送的连接请求都会注册到多路复用器上，多路复用器Selector轮询到连接有IO请求时，才启动一个线程进行处理。基于通道的IO操作，在java.nio包中，提供了接口Channel，抽象类Selector和Buffer。 SocketChannel和ServerSocketChannel对应BIO的Socket和ServerSocket，这两种套接字通道都支持阻塞和非阻塞 Buffer(缓冲区)，IO是面向流的，NIO是面向缓冲区的，NIO中任何写入、读出操作都是直接通过Buffer操作的，常用public abstract class ByteBuffer extends Buffer implements Comparable&lt;ByteBuffer&gt;Channel(通道)，通过Channel进行读写，是双向的，无论读写只能和Buffer交互Selector(选择器)，负责监听IO事件，使用单个线程处理多个通道。线程–&gt;Selector–&gt;n个Channel 虽然多路复用也是阻塞的，但是阻塞在Selector上，而不是阻塞在真正的IO系统调用上 reactor模式反应器模式（事件驱动模型），主要有两部分组成BOSS和WORK，BOSS就像老板，拉活、谈项目，然后下发到worker去处理。处理并发请求，如果有内容进来会自动通知我们，不必开启多个线程死等了。 IO最佳实践 使用有缓冲的IO，不要单独读取字节或字符 尽量不用BIO 在finally中关闭流 使用内存映射文件比IO读写速度更快 JDBCjdbc最佳实践 优先使用批量操作来插入和更新数据 使用PreparedStatement来避免SQL注入 通过列名来获取结果集 使用数据连接池 注解原理注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象，通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。 Mybatis${}和#{}的区别${}是字符串替换；#{}是预编译处理Mybatis在处理${}时，就是把${}替换成变量的值；在处理#{}时，就是讲SQL中的#{}替换成？并调用PreparedStatement的set方法来赋值使用#{}可以有效防止SQL注入，提高系统安全性 当实体类的属性名和表中的字段名不一样，怎么办？ 在查询的SQL语句中定义字段的别名，使其和实体类的属性名一致 123&lt;select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”&gt; select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;&lt;/select&gt; 使用标签来映射字段名和实体类属性名一一对应 123456789101112&lt;select id="getOrder" parameterType="int" resultMap="orderresultmap"&gt; select * from orders where order_id=#&#123;id&#125;&lt;/select&gt; &lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt; &lt;!–用id属性来映射主键字段–&gt; &lt;id property=”id” column=”order_id”&gt; &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt; &lt;result property = “orderno” column =”order_no”/&gt; &lt;result property=”price” column=”order_price” /&gt;&lt;/reslutMap&gt; 在Mybatis全局配置文件中开启驼峰命名，注意：前提是数据库中的字段是按驼峰命名规则的两个单词之间加“_”命名的 12345&lt;settings&gt; &lt;!-- 开启驼峰命名规则，可以将数据库中的下划线映射为驼峰命名 例如：user_name可以映射为userName --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt;&lt;/settings&gt; 通常会有一个dao接口与一个xml映射文件相对应，dao接口的工作原理是什么，其中的方法能重载吗？dao接口即Mapper接口。接口的全限名就是映射文件中的namespace的值；接口的方法名就是文件中Mapper的statement的id值；接口方法内的参数就是传递给sql语句的参数 Mapper接口没有实现类，当调用接口中的方法时，接口全限名+方法名拼接字符串作为key值，可唯一定义一个MapperStatement。（Mybatis中每个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签都会被解析为一个MapperStatement对象） Mapper接口里的方法不能重载，因为Mybatis使用的是全限名+方法名的保存和寻找策略。 工作原理：Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象，代理对象会拦截接口的方法，然后执行MapperStatement所代表的sql，然后将sql执行结果返回。 Mybatis动态sql以标签的的形式编写sql语句，并动态拼接sql语句。有9中标签： trim where set foreach if choose when otherwise bind Mybatis延迟加载Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指一对一，collection指一对多查询；可以配置是否启用延迟加载：lazyLoadingEnabled=true/false 默认为false原理是动态代理形式实现 Spring Boot数据库关系型数据库和非关系型数据库关系型数据库： 支持事务的一致性 支持SQL，可以进行复杂的数据查询 非关系型数据库： 基于键值对，数据没有耦合性，容易扩展 无需SQL层的解析，读写性能很高 可以键值对形式、文档形式、图片形式存储 可用于高并发读写，海量数据的存储和访问，高扩展性。 select语句执行顺序 from where group by 聚合函数 having 计算所有的表达式 select字段 order by对结果集进行排序 为什么用自增列作为主键？如果使用非自增主键，MySQL每次插入新纪录时都会为找到合适的位置而移动其他数据，增加了开销，频繁的移动和分页操作会造成大量的内存碎片，得到不够紧凑的索引结构，不得不用optimize table来重建表来优化和重建页面 OPTIMEZE TABLE当删除数据时，已删除的数据的存储空间和索引位会空在那里等待新的数据弥补空缺，没有数据及时填补空缺会造成资源的浪费，optimeze可以重建表并优化填充页面 存储过程是一个预编译的sql语句，允许模块化，一次创建多次调用；如果某次操作需要执行多次SQL语句，使用存储过程速度更快。 触发器是一种特殊的存储过程，用于保证数据的完整性和一致性。 视图视图是一种虚拟表，通常是一个表或者多个表的行或列的子集，可以进行增、改、查操作，其修改会影响基本表，相比于多表查询，使用视图更容易。 游标是对查询出来的结果集作为一个单元进行处理，游标可以定位在该单元的特定行，从结果集的当前行检索一行或多行，对当前行进行修改处理。一般是需要逐条处理数据时用游标。 drop、truncate、delete区别 drop是删除表 truncate是删除表中数据，下车添加是自增id又从1开始 delete是删除表中数据，可以加where条件 临时表临时表只对当前连接可见，当关闭连接时，所有临时表会被删除，释放内存；临时表和普通表的操作一样，只不过多个关键字TEMPORARY 数据表的连接方式 内连接(inner join)：两张表都有的才能显示出来。 左连接(left join)：左边的表数据都显示出来，右边的表只显示共同的部分，没有的补空。 右连接(right join)：右边的表数据都显示出了，左边的表只显示共同的部分，没有的补空。 外/全 连接(outer join)：两张表数据都显示出来，并去除重复的那部分，没有的补空；MySQL不支持全连接，可用 左连接+右连接+去重 实现。 左连接不包含内连接：只查询左边有的数据，共同的查不出来。 右连接不包含内连接：只查询右边有的数据，共同的查不出来。 外/全 连接不包含内连接：只查询两边不同的数据。以上7中连接如下图所示。 自然连接(natural join):两张表中必须有相同的属性列，无需添加连接条件 笛卡尔积连接：MySQL默认的连接方式，一个表里的记录要分别和另一个表里的记录匹配成一条记录。左表3条记录，右表4条数据，则查询的结果有3*4条数据 char和varchar char长度不可变，会有内存浪费；varchar长度可变 char速度更快 char对英文字符占一个字节，中文字符占两个字节；varchar对英文和中文都占两个字节 索引 索引文件以B树的格式保存 索引可以加快数据的检索速度 可以加速表与表之间的连接 在唯一、不为空、经常被查询的字段适合建索引 索引可以提高select的效率，但同时也降低了insert和update的效率，因为insert或update时可能会重建索引聚集索引、非聚集索引 聚集索引：表记录的排列顺序和索引的排列顺序一致，查询效率快 非聚集索引：排序不一致 数据库的隔离级别 Read Uncommitted 读未提交，一个事务可以读取到另一个未提交的事务。可能会出现脏读 Read Commited 读已提交（SQL Server 、Oracle默认），一个事务要等另一个事务提交后才能读取数据。可能会有不可重复读问题，即一个事务中出现了其他事务对该事物的update操作，导致两次相同的查询返回不同的结果。 Repeatable read 重复读（MySQL默认），开启事务后不再允许修改（update）操作。可能会出现幻读，insert问题，一个事务按相同的查询条件查询两次，结果不一样，中间被insert了新数据 Serializable 序列化/串行化，事务的最高隔离级别，可以有效避免脏读、不可重复读、幻读，但效率低下，消耗数据库性能 存储引擎 MyISAM：易于管理，能够快速读取，适用于频繁查询的应用，适合小数据、小并发。 InnoDB: 支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引，适合查询和更新比较多的应用、适合大数据、大并发。也是MySQL默认的存储引擎 高并发下，如何做到安全的修改一行数据？ 使用悲观锁 写一个队列 SQL优化 当只要一行数据时，用limit 1；//这样找到一条数据后就会停止搜索了 用not exists 代替not in；//not exists用到了建立的索引的作用，not in会每条记录进行比较 尽量不采用不利于索引的操作，如not in，in ，is null，is not null，&lt;&gt;等。 避免在where语句上进行null值判断 避免select * from table，用具体的字段表示 limit的基数比较大是用between and代替 某个字段总要拿来搜索就为其建立索引：alert table tableName add index (字段名) Redisredis是什么？是开源的由C语言编写，支持网络、可基于内存也可持久化的日志型、key-value数据库。 redis有哪些使用场景？ 数据高并发的读写 海量数据的读写 对扩展性要求较高的数据 redis有哪些功能？ 数据持久化 数据缓存 分布式锁 支持事务 支持消息队列 redis支持的数据类型有哪些？ String List hash set zset redis为什么是单线程的？因为redis是基于内存的操作，性能比较高，可以轻松处理每秒几十万的请求，redis要注意的是机器内存和网络宽带，而不必在意CPU，况且多线程会带来其他不必要的麻烦。 什么是缓存穿透？查询一个不存在的数据时，由于缓存中没有就会从数据库中查询，查不到的数据不会写入缓存，导致每次请求都要从数据库中查询，造成缓存穿透。 解决方案：把查询出的空结果放到缓存中，但它的过期时间很短，最长不超过5分钟 NettyNetty的特点Netty是一个基于NIO框架，异步、事件驱动的网络通信框架，它大大简化了TCP、UDP服务器的网路编程。 高并发：基于NIO(NonBlocking I/O,非阻塞IO) 传输快：具有零拷贝特性，减少了不必要的内存拷贝，传输更快 封装好：封装了NIO操作的很多细节，提供了易于使用的调用接口 功能强大：预置了多种编解码功能，支持多种主流协议 Netty的流程 创建客户端和服务器的启动类对象BootStrap和ServerBootStrap 创建多线程事件循环器，bossGroup线程和workerGroup线程，并将两个线程关联起来。bossGroup线程用于创建、连接、绑定socket，然后把这些socket传给workerGroup线程池。ServerBootStrap监听的一个端口对应一个bossGroup线程。 指定Channel的类型为NIOServerSocketChannel 指定ChannelHandler，通过匿名内部类ChannelInitializer类，重写initChannel方法，来配置ChannelHandler，并提供一个ChannelPipeline把ChannelHandler加入到ChannelPipeline中。 异步阻塞方式绑定服务器端口，并启动去接收进来的连接。 关闭启动类对象（调用shutdownGracefully()方法会在线程执行完毕后再退出）。 Netty的零拷贝包含三个方面： Netty发送和接收ByteBuffer采用直接缓冲器(Direct Buffers)，使用堆外直接内存进行socket读写，省去了传统方法中堆内存(Heap Buffers)拷贝数据到直接内存这个步骤。 Netty采用了组合Buffer对象，可以聚合多个ByteBuffer对象，可以像操作一个Buffer对象一样对组合Buffer进行操作，避免的传统的通过内存拷贝的方式将多个Buffer组合成一个Buffer Netty的文件传输采用了transferTo方法，可以直接将文件缓冲区的数据发给目标channel，避免了循环write的方式导致内存拷贝问题 Netty和Tomcat的区别Tomcat是基于http协议的，而Netty可以自己解码编码字节流，自定义各种协议。 Netty的重要知识 Channel：传入和传出数据的通道，可打开和关闭 EventLoop：处理IO操作的多线程事件循环器，将每个Channel注册到一个EventLoop中 ChannelPipeline：是Channel的数据管道，也保存了与Channel相关的ChannelHandler，可动态修改，有丰富的API以响应入站和出站（客户端–&gt;服务器）事件 ChannelHandler：处理入站和出站数据的容器，ChannelHandler被添加到ChannelPileline时，会被分配一个ChannelHandlerContext。 ChannelHandlerContext：代表了ChannelHandler和ChannelPileline之间的绑定，可以获取底层的Channel，但主要是用于写出站数据 ChannelFuture：异步操作结果，其addListener()方法注册了一个ChannelFutureListener，以便在某个操作完成（无论是否成功）时得到通知。 回调：当一个新的连接已经被建立时，ChannelHandler 的 channelActive(ChannelHandlerContext ctx)回调方法将会被调用。 ChannelRead(ChannelHandlerContext ctx，Object msg)：服务端每当从客户端收到新的数据时，被调用。 Netty两种发送消息的方式 直接写入到Channel；消息会从ChannelPipeline的尾端开始流动。 写入与ChannelHandler的相关联的ChannelHandlerContext对象中；消息会从ChannelPileline中的下一个ChannelHandler中开始流动。 Active MQ端口号8161和61616默认配置下会启动这两个端口，8161是自带的管理后台的端口，61616是供Java用的服务端口 ActiveMQ的流程 传入IP和端口号创建一个连接工厂对象 使用连接工厂创建一个连接 开启连接 使用连接创建会话对象 使用会话对象创建目标对象（包括一对一queue或者一对多topic），并通过目标对象创建生产者对象 使用会话对象创建消息对象 使用生产者对象发送消息 关闭资源（连接对象、会话对象、生产者对象） Shiro各个组件 Subject：代表”当前用户”，所有的Subject都绑定到SecurityManager，与Subject所有的交互都交由SecurityManager，SecurityManager才是真正的执行者 SecurityManager：安全管理器，相当于SpringMVC的DispatcherServlet，是Shiro的核心部分，负责认证、授权、会话、缓存的管理 Realm域：域，充当了Shiro与数据间的连接器DAO SessionManager：会话管理，管理会话生命周期的组件 Shiro的运行流程 程序代码调用Subject的API 所有的Subject都绑定到SecurityManager，与Subject的交互都交由SecurityManager完成 SecurityManager从Realm域中获取安全数据（用户、角色、权限）进行操作。 Shiro的四种权限控制方式 url级别权限控制 方法注解权限控制 页面标签权限控制 代码级别权限控制 Git分布式版本控制系统，由Linus用C语言编写，本地仓库包含历史库和代码库 Workspace：工作区 Index/Stage：暂存区 Repository：本地仓库区 Remote：远程仓库 从github上克隆一个仓库$ git clone git@github.com:VAQYA/orgingit.git 常用指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758git fetch 从远程获取最新版本到本地，不会mergegit merge 合并某分支到本分支git pull 相当于前两个的功能文件操作：pwd 显示当前目录mkdir 创建新文件夹cd 转换的此文件夹ls -ah 展示当前文件(夹)类别，包括隐藏文件git init 把当前目录变为Git可以管理的仓库rm file.txt 删除文件file.txt把修改后的文件提交到仓库：1. git add file.txt 把对文件的修改放到暂存区2. git commit -m "说明" 把暂存区的修改一次性全部提交到分支git status 查看仓库的修改状态git diff 查看修改情况，即工作区和暂存区的区别git log 查看提交历史记录git log-pretty=oneline 版本回退：git reset --hard HEAD^ 回退到上一个版本git reset --hard HEAD~100 回退到前100个版本git reset --hard HEAD&lt;版本号前几位&gt; 回退到此版本git relog 查看回退记录的每一次命令，包括删除又恢复的历史记录撤销修改：场景一：改错了file文件，则丢掉工作区对file文件的修改 git checkout --file.txt 场景二：改错了file文件并提交到了暂存区，则 git reset HEAD file 就回到了场景一场景三：改错了file文件并添加到了暂存区，还提交到了版本库 参照版本回退分支：类似于平行宇宙，使用分支更安全，建议使用git branch 查看分支git branch &lt;bName&gt; 创建分支git checkout &lt;bName&gt; 切换分支git checkout -b &lt;bName&gt; 创建+切换分支git merge &lt;bName&gt; 合并某分支到当前分支git branch -d &lt;bName&gt; 删除某分支git branch -D &lt;bName&gt; 强制删除某分支，即使该分支有还没合并到本分支的内容git log -graph 查看分支合并图标签：指向一次commit的id，通常给一个开发分支做标记git tag 查看所有标签git tag v1.0 在当前分支上打标签git tag -a v1.1 -m "说明文字" 在当前分支上打带有说明文字的标签git log --pretty=oneline tagA..tagB 查看某两次之间的commitgit log --pretty=oneline tagA.. 查看某个标签之后的commit git push origin &lt;tagName&gt; 推送一个本地标签到远程库git push origin --tags 推送所有为推送的标签到远程库git tag -d &lt;tagName&gt; 删除标签 ### SVNSubversion，集中式版本控制系统从图书馆借本书，在家里修改，修改后还给图书馆123456789101112默认端口号3690repository 存放文件和对文件的修改历史checkout 提取到私人的工作空间，再进行内容的修改commit 提交操作，是原子操作，要么成功，要么失败回滚update 更新版本库status 列出工作副本所做出的变动列表diff 查看这些变动的详细信息revert 销毁待变更列表，并将工作状态恢复到初始状态merge 自动处理可以全合并的东西resolve 找出冲突，并告诉版本库如何处理冲突 ###servlet是单例吗？servlet不是单例，只是容器只实例化它一次，表现出单例的效果。ServletContext可以进行多线程读写操作，所以不是线程安全的，ServletContext中药尽量少保存会被修改的数据 JVMJDK1.8中用元数据空间代替了JDK1.7的永久代（调优比较困难），Metaspace所占用的内存空间不是虚拟机内部的，而是本地内存空间。 垃圾回收Tomcat的结构，以及其类加载流程，线程模型，如何调优核心组件： Connector连接器，负责接收请求并把请求交给Container Container，一个容器，主要装具有处理请求的组件（service是对外提供服务的组件，将他们两个关联起来处理请求 类加载器流程： Bootstrap引导类加载器，加载JVM启动所需要的类，以及标准扩展类 System系统类加载器 Webapp应用类加载器 Common通用类加载器 线程模型：支持BIO、NIO、APR、AIO 乱乱乱了步伐jdk带的反编译工具javap UUID:唯一通用识别码格式：xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxx(8-4-4-12)String uuid = UUID.randomUUID( ).toString( ).subString( 0 , 5 );]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[注释]]></title>
    <url>%2FJava%2F%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解定义通过@interface定义，比接口多个@注： 注解并不是代码本身的一部分。 元注解可以注解到注解上的注解，是一种基本注解，有5种。 @Retention 说明注解的存活时间取值：RetentionPolicy.SOURCE ,只在源码阶段保留，在编译器编译时将被丢弃忽视。Retention.CLASS , 注解只被保留在编译进行的时候，不会被加载到JVMRetention.RUNTIME , 可以保留在程序运行的时候，会被加载到JVM，所以程序运行时可以获取到它们。 @Documented 将注解中的元素包含到javadoc中 @Target 用于指定注解可以运用的地方取值：ElementType.TYPE , 可以给类型注解，如类、接口、枚举ElementType.FIELD , 给属性注解ElementType.METHOD , 方法ElementType.PARAMETER , 形参ElementType.CONSTRUCTOR , 构造器ElementType.LOCAL_VARIABLE , 局部变量ElementType.ANNOTATION_TYPE , 表示可以给注解进行注解ElementType.PAKAGE, 包ElementType.TYPE_PARAMETER , 指定参数类型（1.8之后）ElementType.TYPE_USE , (1.8之后） @Inherited 继承注解Test被@Inherited注解，类A被Test所注解，类B继承A，则也拥有Test这个注解 @Repeatable 可重复（1.8之后）被它注解的注解可以同时取多个 注解的属性即成员变量，注解没有方法 常用注解@Deprecated 标志已过时的元素@Override 提醒子类要重写父类的此方法@SuppressWarnings 忽略编译警告 ，应在尽可能小的范围内使用它@SafeVarargs 提醒开发者不要用参数做不安全的操作，它会阻止编译器产生unchecked 警告@FunctionalInterface 函数式接口注解，表示一个仅有一个方法的接口 （1.8加入） 作用 提供信息给编译器 编译阶段时的处理，软件工具可以根据注解生成代码、HTML文档，或做其他处理 可以在程序运行时接受代码的处理。如用反射 @Service和@Bean@Qualifier(“name1”)一个接口可能有多个实现类，多个实现类上都有@Service, @Qualifier(“name1”)表示指明调用@Service(“name1”)的这个，name1必须是已经定义过@Service(“name1”)注解的名称，或@Bean(“name1”)过的]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2FJava%2FSpring%2F</url>
    <content type="text"><![CDATA[SpringEnglishdefinition 定义processor 处理器transactional 事务性propagation 传播isolation 隔离 事务-传播属性 propagation即多个事务同时存在时，Spring怎么处理这些行为 @Transactional(propagation = Propagation.REQUIRED)在B方法上声明 propagation.REQUIRED 默认如果外层有事务，则当前事务加入到外层事务，如果没有，则创建一个外层事务，一起提交，一起回滚A方法调用B方法，A、B任一出错，则一起回滚 propagation.REQUIRES_NEWA方法调用B方法，A事务挂起，B新建一个事务，B出错不影响A，B出错只是B回滚，只有A内不包括B的代码出错A才回滚 propagation.SUPPORTSA方法调用B方法，如果A声明了事务，则B按照事务执行，如果A没有声明事务，则B也按照非事务形式执行 propagation.NOT_SUPPORTED不支持事务，无论是否异常都不回滚 propagation.MANDATORYA方法调用B方法，A必须也声明了事务，否则就抛出异常 propagation.NEVERA方法调用B方法，A必须不能声明事务，否则就抛出异常，与MANDATORY相反 propagation.NESTED该传播机制的特点是可以保存状态保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，即各自回滚各自的，如果子事务没有把异常吃掉，基本还是会引起全部回滚的。如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。 事务-隔离级别@Transactional(isolation = Isolation.DEFAULT)在B方法上声明 Isolation.DEFAULT 使用数据库的隔离级别 Isolation.READ_UNCOMMITTED 读未提交 最低的隔离级别，事务未提交前就可以被其他事务读取（会出现 幻读、脏读、不可重复读） Isolation.READ_COMMITTED 读已提交 一个事务提交后才能被其他事务读取 （会出现 幻读、不可重复读） SQL Server的默认级别 Isolation.REPEATABLE_READ 可重复读 保证多次读取同一数据时，其值都和开始时的数据一致，禁止读取到别的事务未提交的数据 （会出现幻读） MySQL的默认级别 Isolation.SERIALIZABLE 序列化 代价最高最可靠。 Spring由那些模块组成？ Core module bean module Context module Expression language module JDBC module ORM module OXM module Java Message Service module Transaction module Web module Web-Servlet module Web-Struts module Web-Portlet module 容器 BeanFactory，Spring中最底层的接口，只提供了最简单的容器功能，实例化对象和拿对象。启动时不会实例化，从容器中拿Bean时才会，占用资源较少ApplicationContext，高级容器，间接实现了BeanFactory接口，具备了更多的功能，如资源的获取(URL或文件)。启动时就把所有Bean实例化了，运行速度较快 IOCInversion of Control,控制反转。负责创建对象、通过DI（依赖注入）管理对象、装配对象、配置对象，并管理这些对象的生命周期。优点：把应用的代码量降到最低，更容易测试，最小的侵入性实现松散耦合。这里的解耦合指的是接口和实现类之间的解耦，在实现类中声明引用型属性，并添加它的setter方法，直接用引用型属性调用实现类。 serviceimpl中添加引用型属性dao,用dao直接调用dao的A方法，就能实现daoImpl调用它的A方法（即service的实现类直接使用dao接口，不知道dao具体的实现类，Spring容器内部完成了这些）。之前的方式：Dao dao = new DaoImpl( );现在的Spring方式：Dao dao; dao的setter方法，这两步。 DI依赖注入Dependency Injection，IOC容器初始化bean的实例对象后，会对对象的属性进行初始化，这个过程就是依赖注入两种方式： 构造器注入通过容器触发一个类的构造器来实现，构造器中有一系列参数，每个参数代表对其他类的依赖。建议用于强制依赖缺点：代码多影响可读性不好维护 setter方法注入容器通过调用无参构造器或无参静态工厂方法实例化bean之后，调用该bean的setter方法实现属性的注入。建议用于可选依赖缺点：不能将对象设为final 属性注入@Autowirde缺点：可能会NPE、不能final修饰、不通过反射不能被实例化 AOP面向切面编程把应用业务逻辑和系统服务（如日志、事务管理）分开，底层使用动态代理方式实现Spring AOP仅支持方法级别的PointCut 连接点(joinPoint)：类里面可以被增强的方法 切入点(Pointcut)：类里面实际增强的方法 通知/增强(Advice)：实际增强的逻辑功能1. 前置通知(before)：在方法前执行 - - - - - - -@Before 2. 后置通知(after)：在方法后执行，无论是方法正常退出还是异常返回，类似于finally - - - - - - @After 3. 最终通知(after-returning)：后置之后执行，方法正常返回后执行 - - - - - - -@AfterReturning 4. 异常通知(after-throwing)：方法抛出异常退出时执行 - - - - - -@AfterThrowing 5. 环绕通知(aroud)：分别在方法执行之前和之后执行 - - - - - @Around 切面(Aspect)：把增强应用到切入点的过程 引入(Introduction)：引入新的接口以及一个对应的实现到任何被代理的对象 目标对象(Target Object)：被一个或多个切面所通知的对象，又叫被通知对象 织入(Weaving):把增强应用到目标对象，来创建新的代理对象的过程，是在运行时执行的。 如何理解Spring中的代理将Advice应用在目标对象创建的对象称为代理tagart + Advice = Proxy Spring beans是被Spring IOC容器中配置的元数据初始化并管理的对象，不是线程安全的。一般来说很少在spring bean里放一些实例变量，一般都是多组件互相调用，最终访问数据库 如何给Spring提供配置元数据？ XML配置文件 基于注解 基于Java的配置 bean的作用域 singleton 只有一个实例（默认） prototype 一个bean可以有多个实例 只在基于Web的Spring ApplicationContext情形下有效 request 每个请求都会创建一个bean session 在一个Http Session中，一个bean定义对应一个实例 global-session 在一个全局的Session中，一个bean定义对应一个实例 bean的生命周期 有两种：Bean工厂对bean的管理、上下文对bean的管理 （由beanFactory读取bean的定义文件）实例化bean 依赖注入bean的属性 如果bean实现了org.springframework.beans.factory.BeanNameAware接口，则执行其setBeanName()方法 如果bean实现了org.sprignframework.beans.factory.BeanFactoryAware接口，则执行其setBeanFactory()方法 如果bean实现了ApplicationContextAware接口，则执行其setApplicationContext()方法。//线程只是帮我们去做一些事情，不要让线程去获取数据（例如applicationContext），最好是就这样在开启线程前就将数据给线程 如果bean实现了org.springframework.beans.factory.BeanPostProcessors接口，则Bean在初始化之前都会执行这个实例的postProcessBeforeInitialization(Object obj, String s)方法，即前置增强方法。 如果bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet()方法。同样，如果在配置文件中声明了初始化方法，指定了bean的init-method，则调用它。 如果bean实现了org.springframework.beans.factory.BeanPostProcessors接口，则Spring将调用它的postprocessAfterInitialization(Object obj, String s)方法 此时bean已经准备就绪，可以被应用程序使用了，将一直驻留在应用上下文中，直到应用上下文被销毁 如果bean实现了DisposableBean接口，Spring将调用它们的destroy()方法。同样，如果配置文件中声明了bean的销毁方法destroy-method，则调用它。 注解 开启注解扫描：&lt;context: component-scan base-package=””&gt;&lt;/context: component-scan&gt; @Configuration 功能同@Component，但是所有带@bean的方法都会被动态代理，所以调用该方法返回的都是同一个实例 @Component 用于类上，实例化bean，相当于配置文件中的 @Bean 表示此方法会返回一个对象，作为一个bean注册进上下文 @Required 用在setter方法上，表明当前bean的这个属性必须在配置的时候设置值，否则会报错 @Autowrited 以类型方式依赖注入属性，可用在构造器、Setter方法及其他普通方法上，如果方法没有bean参数，将会抛出异常，如果有多个bean，则抛出异常没有表明指定哪个bean进行自动装配; 它替代了配置文件中的 元素 @PathVariable - 用于将动态值从URI映射到处理程序方法的参数 @Autowirde 用于Spring bean自动装配依赖项 @Qualifier value属性，指定bean的名称，避免用@Autowirde时存在多个bean实例出现混淆 @Scope 配置bean的使用范围 @Configuration 定义扫描的路径从中找出标识了需要装配的类自动装配到spring的bean容器中，默认扫描@Component, @Repository, @Service, @Controller注解的类，相对应XML配置的context:component-scan/ @Aspect，@Before，@After，@Around，@Pointcut - 用于切面编程（AOP） @RequestMapping 将HTTP请求的URL映射到对应控制器中的特定类/方法上，可用在类和方法上。 @Autowired和@Resource 都可以用来装配Bean，可用于属性或set方法上@Autowired 按照类型装配。 required属性，默认true，不允许为null@Resource 按照名称装配，找不到名称了就按照类型。 name属性指定bean的名称，type属性指定bean的类型 @Qualifier value属性，指定bean的名称@Autowired + @Qualifier = @Resource @Component在接口上时会报错原因接口不能实例化 @Component、@Controller、@Service、@Repository@Component 实例化Bean，将Bean注入到Spring容器进行管理。 其他三个是@Component的功能扩展，针对不同的场景用相应的注解 @Controller 作用于表现层， 将请求进行转发、重定向。@Service 作用于业务逻辑层， 处理业务逻辑。 接口实现类上@Repository 作用于持久层， 作为DAO对象，可直接对数据库进行操作。 能够将数据库操作抛出的原生异常转化为Spring的数据访问异常。 动态代理 jdk动态代理要求被代理的类必须实现接口，利用反射技术，调用了Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法生成字节码，动态创建一个代理类。 cglib动态代理，可以在运行期扩展Java类和实现Java接口，底层实现是通过ASM字节码处理框架来转换字节码并生成新的class（被代理类的子类）；速度上比jdk动态代理要快。 Spring AOP 中的代理使用逻辑：如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理实现 AOP；如果目标对象没有实现了接口，则采用 CGLIB 库；Spring 会自动在 JDK 动态代理和 CGLIB 动态代理之间转换。 Spring都用到了哪些设计模式？ 工厂模式：BeanFactory就是简单工厂模式，用来创建对象实例 单例模式：Bean默认为单例模式 代理模式：Spring的AOP功能用到了jdk动态代理模式和cglib字节码生成技术,实现了接口的类采用JDK动态代理否则采用cglib 模板方法：用来解决代码重复的问题，如RestTemplate，JmsTemplate，JdbcTemplate 观察者模式：定义对象一对多的依赖关系，当一个对象的状态发生改变时，其他对象都会得到通知被制动更新，在Spring中listener的实现，如ApplicationListener springboot-validation-over-json@RestControllerAdvice作用在类上，表示增强某个逻辑功能 @ExceptionHandler(value = GlobalErrorInfoException.class)作用在方法上，当创建一个GlobalErrorInfoException对象时，此方法会被调用 web.xml配置在web.xml中配置Spring的配置文件applicationContext.xml,需要为其配置ContextLoaderListener监听器12345678&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; Spring提供ServletContextListener的一个实现类ContextLoaderListener监听器，启动tomcat容器时，该类的作用就是自动装载ApplicationContext的配置信息，如果没有设置contextConfigLocation的初始参数，则会使用默认WEB_INF路径下的application.xml文件。 ContextLoaderListener会读取这些xml文件产生的WebApplicationContext对象，然后将这些对象放置在ServletContext的属性里，这样我们只要可以得到Servlet就可以得到WebApplicationContext对象，并利用对象访问Spring容器管理的bean。 ps: web.xml中元素的加载顺序：context-param–&gt;listeners–&gt;filters–&gt;servlets(load on startup)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Shiro]]></title>
    <url>%2FJava%2FShiro%2F</url>
    <content type="text"><![CDATA[Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。 Shiro的核心部分是SecurityManager，负责安全认证和授权 Subject 主体 代表了当前操作“用户”，是个抽象概念，不一定是指具体的人，与当前应用交互的任何东西都称为Subject，如第三方进程、后台帐户,网路爬虫、机器人。所有的Subject都绑定到SecurityManager，与Subject的所有交互，都委托给SecurityManager，SecurityManager才是实际的执行者。 通过SecurityUtils.getSubject()来获取Subject，Subject再获取Session对象subject.getSession(),这里的Session对象并不是HttpSession，它不需要依赖http服务器，Shiro的Session的默认实现类实现类：org.apache.shiro.mgt.DelegatingSession SecurityManager 安全管理器 相当于SpringMVC中的DispatchServlet，是Shiro的核心部分，所有具体的交互都通过它进行控制，SecurityManager管理着所有Subject、且负责进行认证、授权、会话、缓存的管理。 AuthenticationInfo 角色信息集合 负责Subject认证。 AuthorizationInfo 角色的权限信息集合 授权器，用来决定主题是否有权限进行相应的操作 Realm 域 充当了Shiro与数据间的连接器，当用户执行角色登陆和权限验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。相当于一个安全相关的DAO，封装了数据源的连接细节，并在需要时将数据提供给Shiro，配置Shiro时，必须至少指定一个Realm。Realm提供AuthenticationInfo和AuthorizationInfo两个对象。 SessionManager 会话管理 管理会话生命周期的组件 CacheManager 缓存控制器 来管理用户、角色、权限等缓存的，因为这些数据基本上很少改变，放入缓存可以提高访问性能。类似于Map&lt;String,Object&gt;对象，通过put保存对象，get取回对象。 Cryptgraphy 密码模块 Shiro提供的加密组件，用于密码的加密解密。 获取Subject对象。 测试当前用户是否已经被认证，即是否已经登录，调用Subject的isAuthenticated（）方法。 没有登录的话，把用户名和密码封装为UsernamePasswordToken对象，UsernamePasswordToken token = new UsernamePasswordToken（”username”,”password”）; 创建表单页面 把请求提交到SpringMVC和Handler 获取用户名和密码 token.setRememberMe(true); 调用Subject对象的login(token)方法执行登录。 登录时的几种异常 UnknownAccountException 没有指定用户 。 IncorrectCredentialsException 账户存在，密码不匹配。 LockedAccountException 用户被锁定。 AuthenticationException 前三种异常的父类。 自定义Realm方法，从数据库中获取对应的记录，返回给Shiro 实际上需要继承org.apache.shiro.realm.AuthenticatingRealm类实现doGetAuthenticationInfo（AuthenticationToken）方法 由Shiro完成与密码的比对 执行登出 Subject对象的logout()方法。判断是否有这个角色，Subject对象调用hasRole(“username”)方法。判断用户是否有这种权限，Subject对象调用isPermitted(“)方法。.ini配置文件规则：用户名=密码，角色1，角色2角色=权限1，权限2即根据用户名找角色，再根据角色找权限。角色= 类型：操作：实例 12345678910111213141516171819202122applicationContext.xml中配置&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;propertry name="securityManager" ref="securityManager"/&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;property name="successUrl" value="/list.jsp"/&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; &lt;!--配置那些页面需要保护，以及访问这些页面需要的权限,首次配置优先 anon 可以被匿名访问 authc 必须认证（即登陆）后才能访问的页面 logout 登出 --&gt; &lt;propertry name="filterChainDefinitions"&gt; &lt;value&gt; /login.jsp = anon /shiro/login = anon /shiro/logout = logout /** = authc &lt;/value&gt; &lt;/propertry&gt;&lt;/bean&gt; ShiroRealm.java继承AuthenticationRealm类，重写方法doGetAuthenticationInfo（AuthenticationToken token），返回AuthenticationInfo对象1234567891011121314方法体：1.把AuthenticationToken对象转换成UsernamePasswordToken对象AuthenticationToken upToken = (UsernamePasswordToken)token;2.从UsernamePasswordToken中获取usernameString username = upToken.getUsername();3.调用数据库的方法，从数据库中查询username对应的用户记录4.判断异常并抛出5.根据用户信息的情况，来构建AuthenticationInfo对象并返回，通常使用的实现类是SimpleAuthenticationInfoObject principal = username;//认证的实体信息，可以是username，也可以是实体类对象。Object credentials = "123456";//密码。String realmName = getName();//获取当前realm对应的nameSimpleAuthenticationInfo info = new SimpleAuthenticationInfo(principal,credentials,realmName);return info; 密码的比对,通过AuthenticatingRealm的credentialsMatcher属性进行密码的比对。 把字符串加密为MD5：替换当前Realm的credentialsMatcher属性，直接使用HashedCredentialsMatcher对象，并设置加密算法。 String hashAlgorithmName = “MD5”;//加密方式Object credentials = “123456”;//初始密码Object salt = null;//盐int hashIterations = 1024;//加密次数Object result = new SimpleHash(hashAlgorithmName,credentials,salt,hashIterations);//加密结果 授权需要继承AuthoriingRealm类，并实现其doGetAuthorizationInfo方法。AuthorIzingRealm类继承自AuthenticatingRealm，但其并没有实现这个方法，所以认证和授权只需要继承AuthorizingRealm即可，同时实现他的两个抽象方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CDN]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FCDN%2F</url>
    <content type="text"><![CDATA[CDN介绍CDN，Content Delivery Network（内容分发网络），是建立在网络之上的，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网路拥塞，提高用户访问相应速度和命中率。 CDN的关键技术为：内容存储、分发技术。CDN目的：解决因分布、宽带、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等，使用户可就近获得所需内容，解决Internet网络拥挤，提高用户网站响应速度和成功率。 CDN负载均衡设备会根据用户IP地址，以及用户请求的URL，选择一台所属区域的区域负载均衡设备，然后为用户选择一台合适的缓存服务器提供服务，选择依据包括： 根据用户IP地址，判断哪一台服务器距用户最近（类似于JD快递）。 根据用户URL携带的内容名称，判断哪一台服务器上有用户所需内容。 查询各服务器当前的负载情况，判断哪一台服务器尚有服务能力。 全局负载均衡设备把服务器的ip地址返回给用户，用户向缓存服务器发送请求，缓存服务器响应请求。 例如，在HTML中引入阿里的js，而不是本地的js文件，就会向阿里就近服务器上找js或css文件，速度和稳定性有保障，又减少了服务器的资源负担。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2FJava%2F%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[java中Runnable 和 Callable 有什么不同？Runnable和Callable都代表那些要在不同的线程中执行的任务，Runnable从jdk1.0开始就有了，Callable是在jdk1.5出的，Callable的call（）方法可以返回值和抛出异常，而Runnable的run（）方法没有这些功能，Callable可以返回装载有返回结果的Future对象。当run（）或者call（）方法执行完成后，线程会自动结束。 volatile是一个特殊的修饰符，只有成员变量才能使用它。在java并发程序缺少同步类的情况下，多线程对成员变量的操作对其他线程是透明的。volatile变量可以保证下一个读取操作在上一个写操作完成后进行。 Vector使用同步方法来实现线程安全的，ArrayList不是线程安全的。 如何在两个线程间实现共享数据？通过共享对象，或者使用像阻塞队列这样的数据结构。 notify和notifyAll的区别？notify不能唤醒某个具体线程，所以只有一个线程在等待的时候才有用，notifyAll唤醒所有线程，并允许他们之间争夺线程锁，确保至少有一个线程能继续运行。 wait、notify、notifyAll方法都是锁级别的操作，所 以把他们定义在Object中，因为锁属于对象。 sleep（）和wait（）方法的区别？都用来暂停当前运行的程序，sleep（）方法是Thread方法，只是短暂暂停，不释放线程锁，wait( )是对象方法，会释放对象锁。 jsp的四大域对象：pageContext，request，session，application九大内置对象：Request、Response、Session、Out、PageContext、Page、Exception、Application、Config AJAX通过异步模式，可以实现局部刷新，在不更新整个页面的前提下维护数据，承担了一部分本来由服务器承担的工作，从而减少了大量用户下的服务器负载。 SpringMVC的常用注解：@RequestMapping 用于请求url映射@RequestBody 注释实现接收http请求的json数据，将json数据转换为java对象。@ResponseBody 注释实现将controller方法返回对象转化为json相应给客户。 拦截器与过滤器的区别：拦截器是基于java的反射机制，过滤器是基于函数回调的；拦截器不依赖于servlet容器。拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。拦截器可以访问action上下文，值栈（本质是ArrayList）里的对象，而过滤器不能。action声明周期中，拦截器可以多次被调用，而过滤器只能在容器中初始化时被调用。 Struts2和SpringMVC的区别1.springmvc入口是一个servlet前端控制器(DispatcherServlet),struts2入口是一filter过滤器(StrutsPrepareAndExecuteFilter). 2.struts2通过在action类中定义成员变量接收参数,(属性驱动和模型驱动),它只能使用多例模式管理action. springmvc通过在coontroller方法中定义形参接收参数,springmvc可以使用单例模式管理controller. 3.springmvc是基于方法开发的,注解开发中使用requestMapping将url和方法进行 映射,如果根据url找到controller类的方法生成一个handler处理器对象(只包括一个method).struts2是基于类开发的,每个请求过来创建一个action实例,实例对象中有若干个方法.开发中建议使用springmvc,springmvc方法更类似service业务方法. 4.struts2采用值栈存储请求和相应的数据,通过OGNL存取数据,springmvc通过参数绑定期将request请求内容解析,并给方法形参赋值. 5.struts2和springmvc的速度是相当的,由于struts2的漏洞较多,跟多企业使用springmvc 散列算法和加密都是将Object变成一串无意义的字符串，不同的是散列算法是单向的，不可复原。 因为每次接口调用都要搜索方法表，所以接口的调用慢于类调用]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
