<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sql]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fsql%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WMS]]></title>
    <url>%2FJava%2FWMS%2F</url>
    <content type="text"><![CDATA[1001-1234561018-1234561019-10191021-123456 mainPage.jsp用于定义导航链接的部分 bootstrap中的class .navbar 设置nav元素为导航条组件 .navbar-default 控制颜色的属性，默认白 .navbar-inverse 控制颜色的属性，黑 .navbar-nav 设置ul为导航条组件内的列表元素 .navbar-right 设置导航条内元素向右对齐 .navbar-fixed-top 设置导航条组件固定到底部 role=”navigation” 可以增强访问性 .container-fuid 自适应屏幕宽度，即满屏显示 .navbar-header 指定div元素为导航条组件包括品牌图标及切换按钮 .navbar-brand 设置导航条组件内的品牌图标，默认放文字，但也可放图片。 .home 是什么类？ href=”javascript:void(0)” 表示让超链接去执行一个js函数，而不是跳转到一个地址，void(0)表示一个空的方法。与href=”#” 不同的是#包含了位置信息，默认锚点是#top,则会回到网页顶部.dropdown 下拉菜单,默认隐藏菜单，点击时会自动添加.open类，显示菜单项.dropdown-toggle 表明这是个下拉列表，data-toggle属性，表明了后面下拉数据的切换是为哪个class服务的，是和最外容器类名一致。 所有图标都需要一个基类和对应那个图标的类 下拉菜单（小三角） 下拉菜单项，是class为dropdown内的 .container-fuid 自适应布局 .row 表示行 .col 表示列 .col-xs-* 超小屏幕（&lt;768px)使用 .col-sm-* 小屏幕【768px&lt;=宽度&lt;=992px ） .col-md-* 中等屏幕【992,1200） .col-lg-* 大屏幕 大于1200px时使用 栅格系统会自动把每行row分为12列，col-md-2表示显示6个div，每个占2列 data-toggle=”collapse” 隐藏内容data-toggle=”collapse.in” 默认显示内容 AccountHandler.java中，返回一个包含4个字符的图形验证码，并将值设置到用户session中。 window.open(URL,name,specs,replace);打开一个新的浏览器窗口，或查找一个已命名的窗口。参数都可选 $.param()，序列化对象，返回字符串var param = {a:100,b:200};var str = $.param(param);console.log(str);结果为：a=100&amp;b=200 验证码 使用java.awt包，包含了绘制图形的方法 写一个生成验证码的工具类，里面写了个char数组，包含了26个英文字母和9和数字，我没有写0，以免混淆 在访问路径后面加入了时间戳，new Date().getTime() ,如果每次的路径一样，浏览器就会自动加载缓存，加上时间戳后访问的路径就不一样了 使用ImageServlet实时生成验证码图片 定义BufferedImage对象 获得Graphics对象 通过Random类产生随机验证码信息 使用Graphics绘制图片 使用ImageIO输出图片 校验验证码是否正确 获取页面的验证码 获取session中保存的验证码 比较验证码 返回校验结果 刷新验证码js写的点击事件，在url请求中加入新的时间戳，获取新的验证码（awt包中BufferedImage类得到验证码图片，字符串是用Random随机生成的，将字符串存在session中，用ImageIO对象将验证码图片输出。 验证是否登录用Shiro框架的工具类得到当前用户的subject对象，调用isAuthenticated方法，返回false则说明没有登录，执行login方法，跳转到login界面 注销登录用Shiro框架的工具类得到当前用户的subject对象，调用isAuthenticated方法，返回true则说明已经登录，执行logout方法，跳转到login界面 登录信息加密【（密码的MD5+用户ID）的MD5+验证码】的MD5加密 验证密码加密方式（数据库的密码+验证码）的MD5加密 默认保存到数据库中的密码（密码的MD5+用户ID）的MD5 未登录则跳转到login页面在配置文件SpringApplication.xml中,加入过滤器，设置权限，所有请求都设置成authc，即必须登录认证后才能访问。 输入框格式验证bootstrapValidator插件，只需要设置属性值，不能为空notEmpty的提醒信息message；输入的规则，用正则表达式 用户和角色关联自定义域的类中，在doGetAuthorizationInfo方法，角色表和用户-角色关联表连接查询出用户的角色，传参给SimpleAuthorizationInfo（）方法，返回AuthorizationInfo对象,它相当于当前登录用户所拥有的权限的集合。 角色和权限关联在jsp页面使用使用标签库，&lt;shiro: hasRole name=”systemAdmin”&gt;权限的url是配置在数据库中的，后台取出url信息，与请求信息对比，用户登陆后会被shiro的拦截器拦截，得到用户有哪些访问权限。 正常情况下URL路径的拦截设置如下: /admins/user/**=roles[“admin,guest”] 登出时间记录写用户Session监听器，当用户session注销时，记录用户账户登出的时间和用户信息，插入记录表中。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2Funcategorized%2FjQuery%2F</url>
    <content type="text"><![CDATA[Ajax的核心是通过XMLHttpRequest对象，使网页与服务器进行通信，获取非本页的内容，用于异步请求；Jsonp核心是动态添加&lt;script&gt;标签调用服务器提供的js脚本，用于跨域请求。Ajax也可以通过服务器代理解决跨域问题。 jQery对Ajax异步进行了封装，几种常用的方式：$.ajax , $.post , $.get , $.getJSON123456789101112131415$.ajax(&#123; //常用的参数 method //数据的提交方式，get或post url //数据的提交路径 async //是否支持异步，默认true data //需要提交的数据 dataType //服务器返回数据的类型，可指定HTML、xml、json、text success : function()&#123;&#125; //请求成功后的回调函数 error : functin()&#123;&#125; //请求失败后的回调函数&#125;);$.post(&#123; contentType //发送post请求的格式，可指定text/plain,application/json &#125;) $(document).ready(function(){ console.log(“hello”);});等同于$(function()){ console.log(“hello”);}); 12345678910111213bootstrapValidator插件API,使用前导入js文件bootstrapValidator.min.js//获取当前表单的验证状态var flag = $(formName).data("bootstrapValitor").isValid();//触发全部验证$(formName).data('bootstrapValidator').validate();//触发指定字段的验证$(formName).data(“bootstrapValidator”).validateField('fieldName');//重置表单所有验证规则$(formName).data("bootstrapValidator").resetForm(); JavaScript中数组的push方法，向数组的末尾添加一个或多个元素，并返回新的长度。 jQuery中$.each()方法的使用]]></content>
  </entry>
  <entry>
    <title><![CDATA[web.xml配置]]></title>
    <url>%2Funcategorized%2FwebXM%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在web.xml中配置Spring的配置文件applicationContext.xml,需要为其配置ContextLoaderListener监听器12345678&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; Spring提供ServletContextListener的一个实现类ContextLoaderListener监听器，启动tomcat容器时，该类的作用就是自动装载ApplicationContext的配置信息，如果没有设置contextConfigLocation的初始参数，则会使用默认WEB_INF路径下的application.xml文件。 ContextLoaderListener会读取这些xml文件产生的WebApplicationContext对象，然后将这些对象放置在ServletContext的属性里，这样我们只要可以得到Servlet就可以得到WebApplicationContext对象，并利用对象访问Spring容器管理的bean。 ps: web.xml中元素的加载顺序：context-param–&gt;listeners–&gt;filters–&gt;servlets(load on startup)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java面试题-持续更新]]></title>
    <url>%2FJava%2FJavaInterview%2F</url>
    <content type="text"><![CDATA[Java基础面向对象的三（四）大特征封装、继承、多态。（抽象） 封装：就是对数据和数据操作进行封装，只对外界提供一个接口，封装可以提高代码的重用性和安全性。 继承：从已有的类中继承信息创建新的类，提高了代码的复用性，是多态的前提。 多态：分为两种： 编译时多态机制，是静态分派的: 同类中方法的重载。运行时多态机制，是动态分派的：子类中方法的重写。实现多态的前提就是父类的引用或接口的引用指向子类的对象，子类进行方法重写。 多态的好处多态可以实现同样的对象引用调用同样的方法做出不同的事情。具有可扩充性，增加新的子类不影响已经存在的类的结构。 虚拟机中是如何实现多态的通过动态绑定技术，在运行期间判断所引用对象的实际类型，根据实际类型调用对应的方法。 什么是接口，接口的作用接口是一系列方法的声明，方法没有方法体，方法默认是被public abstract修饰的，变量是public static final修饰的。接口需要被其他类实现，这些实现可以有不同的行为。 接口和抽象类的区别 不同点： 抽象类（用abstract修饰的类）中可以有抽象方法和普通方法（没有方法体的方法称为抽象方法），接口中的方法全是抽象方法。抽象类中可以有构造方法，接口中没有。抽象类可以有普通成员变量，接口中没有。抽象类在代码实现上发挥作用，接口主要是定义项目模块之间的通信。一个类只能继承一个抽象类，一个接口可以被多个类实现。 相同点： 都不能实例化对象，子类必须实现抽象类或者接口的全部抽象方法，否则子类也必须定义为抽象类。 重载、重写/覆盖 重载：参数列表不同（个数、顺序、类型），方法名相同，在同一类中。 重写/覆盖：参数列表相同，方法名相同，在子类中，子类的方法修饰符权限必须高于父类，抛出的异常必须比父类范围小。 父类的静态方法能否被子类重写？不能，重写只适用于实例方法，如果子类中有和父类相同签名的静态方法，子类这个方法就会被隐匿，子类只能调用父类的这个静态方法。 不可变对象指对象一旦创建就不能被改变，任何修改都会创建一个新的对象，如String，Integer等包装类。 静态变量和实例变量的区别 静态变量又称为类变量，存在于方法区，程序加载类的字节码时就会给静态变量分配空间，可以直接用类名调用。实例变量在创建实例对象时才被分配空间，实例变量本身存放在堆内存中（动态分配，速度慢），其引用存放在栈中（大小固定，速度快） Java创建对象的几种方式 采用new 通过反射 采用clone 通过序列化机制其中new方式是耦合度最高的，尽量少用new创建对象。 switch中能否用String做参数jdk1.7之后可以。switch不能用在long上。 String s1=”ab”,String s2=”a”+”b”,String s3=”a”,String s4=”b”,s5=s3+s4,那么s2=s5返回什么？false，编译过程中，编译器会将s2优化为”ab”,会将其放置在常量池中，s5则是被创建在堆区，相当于s5=new String(“ab”);ps:Java中字符串的连接（+）实际上都是使用StringBuilder的append()方法，(+)本质上就是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象toString方法成String对象。 String 对象的intern()方法。intern()方法会首先从常量池中查找是否存在该常量值，如果常量池中不存在，则先在常量池中创建，如果已经存在则直接返回。 创建了几个对象 String str = new String(“abc”);创建了几个对象，常量池有abc字段是1个，常量池没有”abc”字段则是2个。 String str=“abc”;创建了几个对象（如果常量池里面已经有对象了就是0个。如果没有就是1个）; new String(“abc”).intern();创建了几个对象（如果常量池里面已经有该字符串对象了就是1个，如果没有就是两个） Java中==和equals()的区别？equals()和hashCode()的区别？ ==是运算符，比较两个变量是否相等，equals()是Object类的方法，比较两个对象是否相等（默认的是比较两个对象的地址，和==结果一样。 hashCode()也是Object类的方法，返回一个哈希值，若两个对象的的equals()是相等的，那么调用hashCode()一定返回相同的哈希值；若equals()比较不相等，hashCode()不一定相等；hashCode()相等，equals()不一定相等；hashCode不等，equals()一定不等。ps:Java规范：使用equals()判断两个相等的对象，必须具有相等的equals()方法，所以重写equals()方法时，一定要重写hashCode()方法。将对象放入集合中先判断集合中是否有此对象的hashCode()，没有再equals()比较。 a+=b 和 a=a+b+=会隐式强转结果类型。 short s1=10; s1=s1+1;错误，s1+1会将结果转为int类型 &amp;和&amp;&amp;&amp;是位操作，&amp;&amp;是逻辑运算符，&amp;&amp;具有短路特性。 内部类就像是独立的实体，提供了更好的封装，除了外围类，其他类都不能访问。 final、finalize、finally final修饰变量不可变，修饰类不能被继承，修饰方法不能被重写；final在构造函数中修饰变量，初始化一个对象并赋值给一个引用变量之前，final域会先被初始化；在获取一个对象的引用之后，再读取其final域的值 finalize方法是Object对象的方法，是对象在被回收之前调用的 finally是与try、catch一起用于处理异常的，一定会执行 浅拷贝和深拷贝 浅拷贝只复制对象，而不复制对象中所引用的对象深拷贝会把对象和其所有引用的对象都复制一遍 static 静态变量 静态方法 静态代码块（多用于初始化） 静态内部类 静态导包 eg: import static java.lang.Math.*; 则此类中就可以用Math类的方法了 使用什么类型表示价格？不是特别关心性能和内存，用BigDecimal对象，加减乘除操作分别为add(BigDecimal value)、substruct(BigDecimal value)、multiply(BigDecimal value)、divide(BigDecimal value)。 byte[]数组和String转换,并设置编码.getBytes(“UTF-8”);new String(b1,”UTF-8”); 可以将int转换成byte类型吗？可以，int是32位，byte是8位，强转会丢失高24位。 垃圾回收java中为什么会有GC机制 安全性 减少内存泄露 减少程序员工作量 GC主要回收的内存主要回收方法区和堆内存，这两个是程序运行期间动态创建的。 JVM运行时数据区主要包括5部分： 程序计数器（Program Counter Register） 虚拟机栈（VM Stack） 本地方法栈（Native Method Stack） 方法区（Method Area） 堆（Heap） Java中的GC什么时候回收垃圾？一个对象不存在任何引用时 如何判断一个对象是否应该被回收（即对象没有被引用）？ 引用计数法（存在互相引用而无法GC的问题） 对象可达性分析算法（常用） 垃圾回收算法 标记-清除 标记-复制 标记-整理 分代回收 简单解释一下垃圾回收Java中垃圾回收最基本的做法是分代回收，内存中的区域一般被划分为3个世代：年轻、年老、永久。对象根据存活时间保存在对应的世代中。 多线程进程和线程进程是程序运行和资源分配的基本单位线程是CPU调度和分派的基本单位 进程在执行过程中拥有独立的内存单元，而多个线程可以共享内存资源 守护线程守护线程为用户线程提供服务，eg:GC线程程序执行完毕，JVM会等待非守护线程运行完毕后关闭，而不会等待守护线程。 线程切换CPU控制权由一个正在运行的线程切换到另一个就绪并等待获取CPU执行权的线程 创建线程的方式 继承java.lang.Thread类 实现java.lang.Runnable接口第二种方式的优点：Java不支持多继承，实现接口后还可以再继承其他类；继承整个Thread类的开销更大 Thread类的start()方法和run()方法线程调用start()方法,表示此线程启动了，此时java虚拟机会调用此线程的run()方法；start()方法真正实现了多线程运行，而无需等待run()方法执行完毕而直接继续执行下面的代码。run()方法只是Thread的一个普通方法，只执行主线程这一个线程，而且要等待run()方法执行完毕，才继续执行下去，这样就达不到写线程的目的了。 怎么检测一个线程是否持有对象监视器？Thread类中的静态方法holdsLock(Object obj),当且仅当对象的监视器（即锁）被当前线程持有的时候才会返回true。 Runnable接口的run()方法和Callable接口的call()方法区别run方法无返回值，call方法可以返回装载有返回结果的Future对象，Future对象调用get()方法可以获得该返回值。两个方法结束后线程会自动结束； Future是个接口，因此可以使用它的实现类FutureTaskpublic interface RunnableFuture extends Runnable , Futurepublic class FutureTask implements RunnableFuture sleep()和wait()方法的区别 sleep()是Thread类的方法，wait()是Object类方法 调用sleep()方法，对象不会释放线程锁，wait()方法会释放对象锁 sleep()睡眠后不会让出系统资源，wait()会让其他线程占用CPU sleep(milliseconds)需要指定一个时间，时间一到自动唤醒，wait()方法配合notify()或notifyAll()使用;wait()和notify()方法必须在同步块中被调用，wait会立即释放锁，notify则会在同步块执行完了再释放。 为何wait(),notify(),notifyAll()方法不放在Thread类中？这三个方法都是对锁进行操作，Java提供的锁是对象级的，而不是线程级的，所以把他们定义在Object类中。 如何在两个线程间共享数据？共享对象即可，通过wait/notify/notifyAll、await/signal/signalAll进行唤醒和等待，阻塞队列BlockingQueue就是为共享数据设计的 如何正确使用wait()?12345synchronized (obj)&#123; while(条件不成立)&#123; obj.wait(); &#125;&#125; 线程局部变量ThreadLocal属于线程自身所有，每个Thread里面都维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，不在多个线程间共享，保证了线程的安全。 生产者消费者模型的作用 通过平衡生产者的生产能力和消费者的消费能力，提升系统的运行效率 解耦，使两者联系更少，独自发展不会受到双方的制约 写一个生产者消费者队列 使用阻塞队列实现1234567891011121314151617181920212223242526//生产者public class Producer implements Runnable &#123; private final BlockingQueue&lt;Integer&gt; queue; public Producer(BlockingQueue q)&#123; this.queue=q; &#125; @Override public void run()&#123; try&#123; while(true)&#123; Thread.sleep(1000); queue.put(produce()); &#125; &#125;catch (InterruptedException e)&#123; &#125; &#125; private int produce()&#123; int n = new Random().nextInt(10000); System.out.println("Thread:"+Thread.currentThread().getId()+"produce:"+n); return n; &#125;&#125; 123456789101112131415161718192021222324//消费者public class Consumer implements Runnable&#123; private final BlockingQueue&lt;Integer&gt; queue; public Consumer (BlockingQueue q)&#123; this.queue = q; &#125; @Override public void run()&#123; while(true)&#123; try()&#123; Thread.sleep(2000); consume(queue.take());//take()方法，取走queue里排在首位的对象 &#125;catch (InterruptedException e)&#123; &#125; &#125; &#125; private consume(Integer n)&#123; System.out.println("Thread:"+Thread.currentThread().getId +"consume:"+n); &#125;&#125; 123456789101112131415//测试public class Test()&#123; public static void main(String[] args)&#123; BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(100); Producer p = new Producer(queue); Consumer c1 = new Consumer(queue); Consumer c2 = new Consumer(queue); new Thread(p).start(); new Thread(c1).start(); new Thread(c2).start(); &#125;&#125; 使用wait-notify来实现12 为什么使用线程池？节省线程创建和销毁的开销，达到线程对象的重用，还可以根据项目控制并发的数量 Java中线程的调度算法抢占式，一个线程用完CPU之后，操作系统根据线程的优先级和线程饥饿情况，算出总的优先级，并分配给下一个时间片给某一个线程执行。 Thread.sleep(0)作用有时某个线程会一直获得CPU的控制权，这样可以手动触发一次操作系统重新分配时间片的操作，平衡CPU的控制权。 什么是CASCompare and Swap 比较-替换。内存值V，旧的预期值A，要修改后的值B。预期值A与内存值V相等时，将内存值修改为B，并返回true。CAS为了取到最新的值，应配合volatile变量。 volatile变量 volatile变量是一种比synchronized更轻量级的同步机制。 对非volatile变量进行读写时，系统先从内存拷贝变量到CPU缓存中；对volatile变量，系统直接从内存中读取，跳过了CPU缓存这一步。 一个线程修改了volatile变量的值，volatile能保证新值能立即同步到主内存，以及每次使用前立即从主内存刷新。 内禁止CPU指令重排序（CPU指令重排序：CPU采用了允许将多条指令不按程序规定的顺序，分开发送各相应电路单元处理） 性能：读和普通变量几乎相同，写操作较慢（因为要在代码中插入内存屏障保证处理器不发生乱序执行） 乐观锁、悲观锁乐观锁：认为线程竞争不总是发生，不需要持有锁，但是在更新数据时要判断别人有没有修改数据，一般用版本号机制和CAS算法实现悲观锁：总是认为线程会竞争，每次拿到数据都会上锁。 ConcurrentHashMap的并发度segment的大小：16，即最多可以16个线程操作ConcurrentHashMap ConcurrentHashMap的工作原理 jdk1.6中 采用分离锁的方式，没有对整个hash表进行锁定，而是局部锁定，不影响其他线程对hash表的其他地方进行访问 jdk1.8中 与1.6不同，它采用了乐观锁CAS算法，底层还是数组+链表-&gt;红黑树 多线程开发良好的实践 给线程命名 考虑使用线程池 优先使用volatile变量 优先使用并发容器而非同步容器 线程通信用高层次的并发工具，如BlockingQueue，少用wait()、notify() 最小化同步范围 集合Java中集合及继承关系 IO流网络编程SpringSpringMVCMybatisSpring BootNettyGit]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Shiro]]></title>
    <url>%2FJava%2FShiro%2F</url>
    <content type="text"><![CDATA[Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。 Shiro的核心部分是SecurityManager，负责安全认证和授权 Subject 主体 代表了当前操作“用户”，是个抽象概念，不一定是指具体的人，与当前应用交互的任何东西都称为Subject，如第三方进程、后台帐户,网路爬虫、机器人。所有的Subject都绑定到SecurityManager，与Subject的所有交互，都委托给SecurityManager，SecurityManager才是实际的执行者。 通过SecurityUtils.getSubject()来获取Subject，Subject再获取Session对象subject.getSession(),这里的Session对象并不是HttpSession，它不需要依赖http服务器，Shiro的Session的默认实现类实现类：org.apache.shiro.mgt.DelegatingSession SecurityManager 安全管理器 相当于SpringMVC中的DispatchServlet，是Shiro的核心部分，所有具体的交互都通过它进行控制，SecurityManager管理着所有Subject、且负责进行认证、授权、会话、缓存的管理。 AuthenticationInfo 角色信息集合 负责Subject认证。 AuthorizationInfo 角色的权限信息集合 授权器，用来决定主题是否有权限进行相应的操作 Realm 域 充当了Shiro与数据间的连接器，当用户执行角色登陆和权限验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。相当于一个安全相关的DAO，封装了数据源的连接细节，并在需要时将数据提供给Shiro，配置Shiro时，必须至少指定一个Realm。Realm提供AuthenticationInfo和AuthorizationInfo两个对象。 SessionManager 会话管理 管理会话生命周期的组件 CacheManager 缓存控制器 来管理用户、角色、权限等缓存的，因为这些数据基本上很少改变，放入缓存可以提高访问性能。类似于Map&lt;String,Object&gt;对象，通过put保存对象，get取回对象。 Cryptgraphy 密码模块 Shiro提供的加密组件，用于密码的加密解密。 获取Subject对象。 测试当前用户是否已经被认证，即是否已经登录，调用Subject的isAuthenticated（）方法。 没有登录的话，把用户名和密码封装为UsernamePasswordToken对象，UsernamePasswordToken token = new UsernamePasswordToken（”username”,”password”）; 创建表单页面 把请求提交到SpringMVC和Handler 获取用户名和密码 token.setRememberMe(true); 调用Subject对象的login(token)方法执行登录。 登录时的几种异常 UnknownAccountException 没有指定用户 。 IncorrectCredentialsException 账户存在，密码不匹配。 LockedAccountException 用户被锁定。 AuthenticationException 前三种异常的父类。 自定义Realm方法，从数据库中获取对应的记录，返回给Shiro 实际上需要继承org.apache.shiro.realm.AuthenticatingRealm类实现doGetAuthenticationInfo（AuthenticationToken）方法 由Shiro完成与密码的比对 执行登出 Subject对象的logout()方法。判断是否有这个角色，Subject对象调用hasRole(“username”)方法。判断用户是否有这种权限，Subject对象调用isPermitted(“)方法。.ini配置文件规则：用户名=密码，角色1，角色2角色=权限1，权限2即根据用户名找角色，再根据角色找权限。角色= 类型：操作：实例 12345678910111213141516171819202122applicationContext.xml中配置&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;propertry name="securityManager" ref="securityManager"/&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;property name="successUrl" value="/list.jsp"/&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; &lt;!--配置那些页面需要保护，以及访问这些页面需要的权限,首次配置优先 anon 可以被匿名访问 authc 必须认证（即登陆）后才能访问的页面 logout 登出 --&gt; &lt;propertry name="filterChainDefinitions"&gt; &lt;value&gt; /login.jsp = anon /shiro/login = anon /shiro/logout = logout /** = authc &lt;/value&gt; &lt;/propertry&gt;&lt;/bean&gt; ShiroRealm.java继承AuthenticationRealm类，重写方法doGetAuthenticationInfo（AuthenticationToken token），返回AuthenticationInfo对象1234567891011121314方法体：1.把AuthenticationToken对象转换成UsernamePasswordToken对象AuthenticationToken upToken = (UsernamePasswordToken)token;2.从UsernamePasswordToken中获取usernameString username = upToken.getUsername();3.调用数据库的方法，从数据库中查询username对应的用户记录4.判断异常并抛出5.根据用户信息的情况，来构建AuthenticationInfo对象并返回，通常使用的实现类是SimpleAuthenticationInfoObject principal = username;//认证的实体信息，可以是username，也可以是实体类对象。Object credentials = "123456";//密码。String realmName = getName();//获取当前realm对应的nameSimpleAuthenticationInfo info = new SimpleAuthenticationInfo(principal,credentials,realmName);return info; 密码的比对,通过AuthenticatingRealm的credentialsMatcher属性进行密码的比对。 把字符串加密为MD5：替换当前Realm的credentialsMatcher属性，直接使用HashedCredentialsMatcher对象，并设置加密算法。 String hashAlgorithmName = “MD5”;//加密方式Object credentials = “123456”;//初始密码Object salt = null;//盐int hashIterations = 1024;//加密次数Object result = new SimpleHash(hashAlgorithmName,credentials,salt,hashIterations);//加密结果 授权需要继承AuthoriingRealm类，并实现其doGetAuthorizationInfo方法。AuthorIzingRealm类继承自AuthenticatingRealm，但其并没有实现这个方法，所以认证和授权只需要继承AuthorizingRealm即可，同时实现他的两个抽象方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CDN]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%2FCDN%2F</url>
    <content type="text"><![CDATA[CDN介绍CDN，Content Delivery Network（内容分发网络），是建立在网络之上的，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网路拥塞，提高用户访问相应速度和命中率。 CDN的关键技术为：内容存储、分发技术。CDN目的：解决因分布、宽带、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等，使用户可就近获得所需内容，解决Internet网络拥挤，提高用户网站响应速度和成功率。 CDN负载均衡设备会根据用户IP地址，以及用户请求的URL，选择一台所属区域的区域负载均衡设备，然后为用户选择一台合适的缓存服务器提供服务，选择依据包括： 根据用户IP地址，判断哪一台服务器距用户最近（类似于JD快递）。 根据用户URL携带的内容名称，判断哪一台服务器上有用户所需内容。 查询各服务器当前的负载情况，判断哪一台服务器尚有服务能力。 全局负载均衡设备把服务器的ip地址返回给用户，用户向缓存服务器发送请求，缓存服务器响应请求。 例如，在HTML中引入阿里的js，而不是本地的js文件，就会向阿里就近服务器上找js或css文件，速度和稳定性有保障，又减少了服务器的资源负担。]]></content>
      <categories>
        <category>计算机网路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2FJava%2F%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[java中Runnable 和 Callable 有什么不同？Runnable和Callable都代表那些要在不同的线程中执行的任务，Runnable从jdk1.0开始就有了，Callable是在jdk1.5出的，Callable的call（）方法可以返回值和抛出异常，而Runnable的run（）方法没有这些功能，Callable可以返回装载有返回结果的Future对象。当run（）或者call（）方法执行完成后，线程会自动结束。 volatile是一个特殊的修饰符，只有成员变量才能使用它。在java并发程序缺少同步类的情况下，多线程对成员变量的操作对其他线程是透明的。volatile变量可以保证下一个读取操作在上一个写操作完成后进行。 Vector使用同步方法来实现线程安全的，ArrayList不是线程安全的。 如何在两个线程间实现共享数据？通过共享对象，或者使用像阻塞队列这样的数据结构。 notify和notifyAll的区别？notify不能唤醒某个具体线程，所以只有一个线程在等待的时候才有用，notifyAll唤醒所有线程，并允许他们之间争夺线程锁，确保至少有一个线程能继续运行。 wait、notify、notifyAll方法都是锁级别的操作，所 以把他们定义在Object中，因为锁属于对象。 sleep（）和wait（）方法的区别？都用来暂停当前运行的程序，sleep（）方法是Thread方法，只是短暂暂停，不释放线程锁，wait( )是对象方法，会释放对象锁。 jsp的四大域对象：pageContext，request，session，application九大内置对象：Request、Response、Session、Out、PageContext、Page、Exception、Application、Config AJAX通过异步模式，可以实现局部刷新，在不更新整个页面的前提下维护数据，承担了一部分本来由服务器承担的工作，从而减少了大量用户下的服务器负载。 SpringMVC的常用注解：@RequestMapping 用于请求url映射@RequestBody 注释实现接收http请求的json数据，将json数据转换为java对象。@ResponseBody 注释实现将controller方法返回对象转化为json相应给客户。 拦截器与过滤器的区别：拦截器是基于java的反射机制，过滤器是基于函数回调的；拦截器不依赖于servlet容器。拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。拦截器可以访问action上下文，值栈（本质是ArrayList）里的对象，而过滤器不能。action声明周期中，拦截器可以多次被调用，而过滤器只能在容器中初始化时被调用。 Struts2action是多例的可分为三个部分：核心控制器FilterDispatch、业务控制器action、用户实现的业务逻辑组件 工作原理：① 客户端初始化一个servlet容器的请求② 请求经过一系列的过滤器③ 接着FilterDispatch被调用④ ActionMapper决定需要哪个action，FilterDispatch把请求的处理交给ActionProxy⑤ ActionProxy通过Configuration Manager询问框架的配置文件，找到需要调用的action类⑥ ActionProxy创建一个ActionInvocation的实例⑦ ActionInvocation的实例通过命名模式来调用Action，前后涉及到拦截器调用⑧ Action执行完毕，ActionInvocation负责根据struts.xml的配置找到对应的返回结果，返回结果通常是jsp。 工作流程 1、客户端浏览器发出HTTP请求. 2、根据web.xml配置，该请求被FilterDispatcher接收 3、根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton 4、Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。 5、Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面 6、返回HTTP响应到客户端浏览器 Struts2和SpringMVC的区别1.springmvc入口是一个servlet前端控制器(DispatcherServlet),struts2入口是一filter过滤器(StrutsPrepareAndExecuteFilter). 2.struts2通过在action类中定义成员变量接收参数,(属性驱动和模型驱动),它只能使用多例模式管理action. springmvc通过在coontroller方法中定义形参接收参数,springmvc可以使用单例模式管理controller. 3.springmvc是基于方法开发的,注解开发中使用requestMapping将url和方法进行 映射,如果根据url找到controller类的方法生成一个handler处理器对象(只包括一个method).struts2是基于类开发的,每个请求过来创建一个action实例,实例对象中有若干个方法.开发中建议使用springmvc,springmvc方法更类似service业务方法. 4.struts2采用值栈存储请求和相应的数据,通过OGNL存取数据,springmvc通过参数绑定期将request请求内容解析,并给方法形参赋值. 5.struts2和springmvc的速度是相当的,由于struts2的漏洞较多,跟多企业使用springmvc 散列算法和加密都是将Object变成一串无意义的字符串，不同的是散列算法是单向的，不可复原。 因为每次接口调用都要搜索方法表，所以接口的调用慢于类调用]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
