<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Shiro]]></title>
    <url>%2FJava%2FShiro%2F</url>
    <content type="text"><![CDATA[Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。Shiro的核心部分是SecurityManager，负责安全认证和授权 Subject 主体 代表了当前操作“用户”，是个抽象概念，不一定是指具体的人，与当前应用交互的任何东西都称为Subject，如第三方进程、后台帐户,网路爬虫、机器人。所有的Subject都绑定到SecurityManager，与Subject的所有交互，都委托给SecurityManager，SecurityManager才是实际的执行者。 通过SecurityUtils.getSubject()来获取Subject，Subject再获取Session对象subject.getSession(),这里的Session对象并不是HttpSession，它不需要依赖http服务器，Shiro的Session的默认实现类实现类：org.apache.shiro.mgt.DelegatingSession SecurityManager 安全管理器 相当于SpringMVC中的DispatchServlet，是Shiro的核心部分，所有具体的交互都通过它进行控制，SecurityManager管理着所有Subject、且负责进行认证、授权、会话、缓存的管理。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CDN]]></title>
    <url>%2Funcategorized%2FCDN%2F</url>
    <content type="text"><![CDATA[CDN介绍CDN，Content Delivery Network（内容分发网络），是建立在网络之上的，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网路拥塞，提高用户访问相应速度和命中率。 CDN的关键技术为：内容存储、分发技术。CDN目的：解决因分布、宽带、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等，使用户可就近获得所需内容，解决Internet网络拥挤，提高用户网站响应速度和成功率。 CDN负载均衡设备会根据用户IP地址，以及用户请求的URL，选择一台所属区域的区域负载均衡设备，然后为用户选择一台合适的缓存服务器提供服务，选择依据包括： 根据用户IP地址，判断哪一台服务器距用户最近（类似于JD快递）。 根据用户URL携带的内容名称，判断哪一台服务器上有用户所需内容。 查询各服务器当前的负载情况，判断哪一台服务器尚有服务能力。 全局负载均衡设备把服务器的ip地址返回给用户，用户向缓存服务器发送请求，缓存服务器响应请求。 例如，在HTML中引入阿里的js，而不是本地的js文件，就会向阿里就近服务器上找js或css文件，速度和稳定性有保障，又减少了服务器的资源负担。]]></content>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2FJava%2F%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[java中Runnable 和 Callable 有什么不同？Runnable和Callable都代表那些要在不同的线程中执行的任务，Runnable从jdk1.0开始就有了，Callable是在jdk1.5出的，Callable的call（）方法可以返回值和抛出异常，而Runnable的run（）方法没有这些功能，Callable可以返回装载有返回结果的Future对象。当run（）或者call（）方法执行完成后，线程会自动结束。 volatile是一个特殊的修饰符，只有成员变量才能使用它。在java并发程序缺少同步类的情况下，多线程对成员变量的操作对其他线程是透明的。volatile变量可以保证下一个读取操作在上一个写操作完成后进行。 Vector使用同步方法来实现线程安全的，ArrayList不是线程安全的。 如何在两个线程间实现共享数据？通过共享对象，或者使用像阻塞队列这样的数据结构。 notify和notifyAll的区别？notify不能唤醒某个具体线程，所以只有一个线程在等待的时候才有用，notifyAll唤醒所有线程，并允许他们之间争夺线程锁，确保至少有一个线程能继续运行。 wait、notify、notifyAll方法都是锁级别的操作，所 以把他们定义在Object中，因为锁属于对象。 sleep（）和wait（）方法的区别？都用来暂停当前运行的程序，sleep（）方法是Thread方法，只是短暂暂停，不释放线程锁，wait( )是对象方法，会释放对象锁。 jsp的四大域对象：pageContext，request，session，application九大内置对象：Request、Response、Session、Out、PageContext、Page、Exception、Application、Config AJAX通过异步模式，可以实现局部刷新，在不更新整个页面的前提下维护数据，承担了一部分本来由服务器承担的工作，从而减少了大量用户下的服务器负载。 SpringMVC的常用注解：@RequestMapping 用于请求url映射@RequestBody 注释实现接收http请求的json数据，将json数据转换为java对象。@ResponseBody 注释实现将controller方法返回对象转化为json相应给客户。 拦截器与过滤器的区别：拦截器是基于java的反射机制，过滤器是基于函数回调的；拦截器不依赖于servlet容器。拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。拦截器可以访问action上下文，值栈（本质是ArrayList）里的对象，而过滤器不能。action声明周期中，拦截器可以多次被调用，而过滤器只能在容器中初始化时被调用。 Struts2action是多例的可分为三个部分：核心控制器FilterDispatch、业务控制器action、用户实现的业务逻辑组件 工作原理：① 客户端初始化一个servlet容器的请求② 请求经过一系列的过滤器③ 接着FilterDispatch被调用④ ActionMapper决定需要哪个action，FilterDispatch把请求的处理交给ActionProxy⑤ ActionProxy通过Configuration Manager询问框架的配置文件，找到需要调用的action类⑥ ActionProxy创建一个ActionInvocation的实例⑦ ActionInvocation的实例通过命名模式来调用Action，前后涉及到拦截器调用⑧ Action执行完毕，ActionInvocation负责根据struts.xml的配置找到对应的返回结果，返回结果通常是jsp。 工作流程 1、客户端浏览器发出HTTP请求. 2、根据web.xml配置，该请求被FilterDispatcher接收 3、根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton 4、Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。 5、Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面 6、返回HTTP响应到客户端浏览器 Struts2和SpringMVC的区别1.springmvc入口是一个servlet前端控制器(DispatcherServlet),struts2入口是一filter过滤器(StrutsPrepareAndExecuteFilter). 2.struts2通过在action类中定义成员变量接收参数,(属性驱动和模型驱动),它只能使用多例模式管理action. springmvc通过在coontroller方法中定义形参接收参数,springmvc可以使用单例模式管理controller. 3.springmvc是基于方法开发的,注解开发中使用requestMapping将url和方法进行 映射,如果根据url找到controller类的方法生成一个handler处理器对象(只包括一个method).struts2是基于类开发的,每个请求过来创建一个action实例,实例对象中有若干个方法.开发中建议使用springmvc,springmvc方法更类似service业务方法. 4.struts2采用值栈存储请求和相应的数据,通过OGNL存取数据,springmvc通过参数绑定期将request请求内容解析,并给方法形参赋值. 5.struts2和springmvc的速度是相当的,由于struts2的漏洞较多,跟多企业使用springmvc]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
